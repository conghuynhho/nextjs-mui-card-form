'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var cn = require('classnames');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var cn__default = /*#__PURE__*/_interopDefaultLegacy(cn);

function getDirectionNames(hDirection, vDirection) {
    var camelCase, snakeCase;
    if (hDirection && vDirection) {
        camelCase = "" + hDirection + vDirection[0].toUpperCase() + vDirection.slice(1);
        snakeCase = hDirection + "-" + vDirection;
    }
    else {
        camelCase = hDirection || vDirection;
        snakeCase = hDirection || vDirection;
    }
    return { camelCase: camelCase, snakeCase: snakeCase };
}
function isBlob(url) {
    return /^blob:/.test(url);
}
function isDataUrl(url) {
    return /^data:/.test(url);
}
function isLocal(url) {
    return isBlob(url) || isDataUrl(url);
}
function isCrossOriginURL(url) {
    if (isLocal(url)) {
        return false;
    }
    var pageLocation = window.location;
    var URL_HOST_PATTERN = /(\w+:)?(?:\/\/)([\w.-]+)?(?::(\d+))?\/?/;
    var urlMatch = URL_HOST_PATTERN.exec(url) || [];
    var urlparts = {
        protocol: urlMatch[1] || '',
        host: urlMatch[2] || '',
        port: urlMatch[3] || '',
    };
    var defaultPort = function (protocol) {
        if (protocol === 'http') {
            return 80;
        }
        else {
            return 433;
        }
    };
    var portOf = function (location) {
        return location.port || defaultPort((location.protocol || pageLocation.protocol));
    };
    return !((!urlparts.protocol && !urlparts.host && !urlparts.port) ||
        Boolean(urlparts.protocol &&
            urlparts.protocol == pageLocation.protocol &&
            urlparts.host &&
            urlparts.host == pageLocation.host &&
            urlparts.host &&
            portOf(urlparts) == portOf(pageLocation)));
}
function isArray(value) {
    return Array.isArray(value);
}
function isFunction(value) {
    return typeof value === 'function';
}
function isUndefined(obj) {
    return obj === undefined;
}
var isObject = function (term) {
    return term !== null && typeof term === 'object';
};
// TODO: add the typing
function getOptions(options, defaultScheme, falseScheme) {
    if (falseScheme === void 0) { falseScheme = {}; }
    var result = {};
    if (isObject(options)) {
        Object.keys(defaultScheme).forEach(function (key) {
            if (isUndefined(options[key])) {
                result[key] = defaultScheme[key];
            }
            else if (isObject(defaultScheme[key])) {
                if (isObject(options[key])) {
                    result[key] = getOptions(options[key], defaultScheme[key], falseScheme[key]);
                }
                else {
                    result[key] = options[key] ? defaultScheme[key] : falseScheme[key];
                }
            }
            else if (defaultScheme[key] === true || defaultScheme[key] === false) {
                result[key] = Boolean(options[key]);
            }
            else {
                result[key] = options[key];
            }
        });
        return result;
    }
    else {
        if (options) {
            return defaultScheme;
        }
        else {
            return falseScheme;
        }
    }
}
function parseNumber(number) {
    var parsedNumber = Number(number);
    if (Number.isNaN(parsedNumber)) {
        return number;
    }
    else {
        return parsedNumber;
    }
}
function isNumber(value) {
    return typeof value === 'number';
}
function isString(value) {
    return typeof value === 'string';
}
function isNaN(value) {
    return value !== value;
}
function isNumeric(value) {
    return ((isNumber(value) && !isNaN(value)) ||
        (isString(value) && !Number.isNaN(parseFloat(value)) && isFinite(parseFloat(value))));
}
function distance(firstPoint, secondPoint) {
    return Math.sqrt(Math.pow(firstPoint.left - secondPoint.left, 2) + Math.pow(firstPoint.top - secondPoint.top, 2));
}
function isRoughlyEqual(a, b, tolerance) {
    if (tolerance === void 0) { tolerance = 1e-3; }
    return Math.abs(b - a) < tolerance;
}
function isGreater(a, b, tolerance) {
    return isRoughlyEqual(a, b, tolerance) ? false : a > b;
}
function isLower(a, b, tolerance) {
    return isRoughlyEqual(a, b, tolerance) ? false : a < b;
}
function isArrayBufferLike(value) {
    return value instanceof ArrayBuffer;
}
function getCloserAngle(reference, angle) {
    var turnsCount = Math.floor(reference / 360);
    var firstCandidate = turnsCount * 360 + angle;
    var secondCandidate = (turnsCount + 1) * 360 + angle;
    if (Math.abs(firstCandidate - reference) < Math.abs(secondCandidate - reference)) {
        return firstCandidate;
    }
    else {
        return secondCandidate;
    }
}
function sign(value) {
    var number = +value;
    if (number === 0 || isNaN(number)) {
        return number;
    }
    return number > 0 ? 1 : -1;
}
function promiseTimeout(timeout) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve();
        }, timeout);
    });
}
// Not performant, small function to reduce the code amount
function deepClone(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var result = {};
    if (Array.isArray(obj)) {
        result = obj.map(function (item) { return deepClone(item); });
    }
    else {
        Object.keys(obj).forEach(function (key) {
            return (result[key] = deepClone(obj[key]));
        });
    }
    return result;
}
function deepCompare(a, b, tolerance) {
    if (tolerance === void 0) { tolerance = 1e-3; }
    if (isNumber(a) && isNumber(b) && isRoughlyEqual(a, b, tolerance))
        return true;
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor)
            return false;
        var length_1, i = void 0;
        if (Array.isArray(a)) {
            length_1 = a.length;
            if (length_1 != b.length)
                return false;
            for (i = length_1; i-- !== 0;)
                if (!deepCompare(a[i], b[i], tolerance))
                    return false;
            return true;
        }
        if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
        var keys = Object.keys(a);
        length_1 = keys.length;
        if (length_1 !== Object.keys(b).length)
            return false;
        for (i = length_1; i-- !== 0;)
            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
                return false;
        for (i = length_1; i-- !== 0;) {
            var key = keys[i];
            if (!deepCompare(a[key], b[key], tolerance))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
function isWheelEvent(event) {
    return 'deltaX' in event;
}
function isTouchEvent(event) {
    return 'touches' in event;
}
function isMouseEvent(event) {
    return 'buttons' in event;
}
function emptyCoordinates() {
    return {
        left: 0,
        top: 0,
        width: 0,
        height: 0,
    };
}
function isCardinalDirection(value) {
    return value === 'west' || value === 'south' || value === 'north' || value === 'east';
}
function isOrdinalDirection(value) {
    return (isCardinalDirection(value) ||
        value === 'westNorth' ||
        value === 'westSouth' ||
        value === 'eastNorth' ||
        value === 'eastSouth');
}
function debounce(callback, delay) {
    var timestamp;
    var timeout;
    function later() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var last = Date.now() - timestamp;
        var delayValue = isFunction(delay) ? delay() : delay || 0;
        if (last < delayValue && last >= 0) {
            timeout = setTimeout(function () { return later.apply(void 0, args); }, delayValue - last);
        }
        else {
            callback.apply(void 0, args);
        }
    }
    function result() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        timestamp = Date.now();
        timeout = setTimeout(function () { return later.apply(void 0, args); }, isFunction(delay) ? delay() : delay || 0);
    }
    result.clear = function () {
        clearTimeout(timeout);
    };
    return result;
}

var ALL_DIRECTIONS = ['left', 'right', 'top', 'bottom'];
var HORIZONTAL_DIRECTIONS$1 = ['left', 'right'];
var VERTICAL_DIRECTIONS$1 = ['top', 'bottom'];

function diff(firstObject, secondObject) {
    return {
        left: firstObject.left - secondObject.left,
        top: firstObject.top - secondObject.top,
    };
}
function getCenter(object) {
    return {
        left: object.left + object.width / 2,
        top: object.top + object.height / 2,
    };
}
function sizeDistance(a, b) {
    return Math.pow(a.width - b.width, 2) + Math.pow(a.height - b.height, 2);
}
function applyDirections(coordinates, directions) {
    return {
        left: coordinates.left - directions.left,
        top: coordinates.top - directions.top,
        width: coordinates.width + directions.left + directions.right,
        height: coordinates.height + directions.top + directions.bottom,
    };
}
function inverseMove(directions) {
    return {
        left: -directions.left,
        top: -directions.top,
    };
}
function applyMove(object, move) {
    return tslib.__assign(tslib.__assign({}, object), { left: object.left + move.left, top: object.top + move.top });
}
function coordinatesToPositionRestrictions(coordinates) {
    return {
        left: coordinates.left,
        top: coordinates.top,
        right: coordinates.left + coordinates.width,
        bottom: coordinates.top + coordinates.height,
    };
}
function applyScale(object, factor, center, progress) {
    if (factor !== 1) {
        if ('left' in object || 'top' in object) {
            if (center) {
                var currentCenter = getCenter(object);
                return {
                    width: object.width * factor,
                    height: object.height * factor,
                    left: object.left +
                        (object.width * (1 - factor)) / 2 +
                        (center.left - currentCenter.left) * (progress || 1 - factor),
                    top: object.top +
                        (object.height * (1 - factor)) / 2 +
                        (center.top - currentCenter.top) * (progress || 1 - factor),
                };
            }
            else {
                return {
                    width: object.width * factor,
                    height: object.height * factor,
                    left: object.left + (object.width * (1 - factor)) / 2,
                    top: object.top + (object.height * (1 - factor)) / 2,
                };
            }
        }
        else {
            return {
                width: object.width * factor,
                height: object.height * factor,
            };
        }
    }
    else {
        return object;
    }
}
function ratio(object) {
    return object.width / object.height;
}
function maxScale(size, restrictions) {
    return Math.min(restrictions.maxWidth ? restrictions.maxWidth / size.width : Infinity, restrictions.maxHeight ? restrictions.maxHeight / size.height : Infinity);
}
function minScale(size, restrictions) {
    return Math.max(restrictions.minWidth ? restrictions.minWidth / size.width : 0, restrictions.minHeight ? restrictions.minHeight / size.height : 0);
}
function getBrokenRatio(currentAspectRatio, aspectRatio) {
    var ratioBroken;
    if (aspectRatio.minimum && isLower(currentAspectRatio, aspectRatio.minimum)) {
        ratioBroken = aspectRatio.minimum;
    }
    else if (aspectRatio.maximum && isGreater(currentAspectRatio, aspectRatio.maximum)) {
        ratioBroken = aspectRatio.maximum;
    }
    return ratioBroken;
}
function fitToSizeRestrictions(coordinates, sizeRestrictions) {
    var aspectRatio = ratio(coordinates);
    var scale = 1;
    if (sizeRestrictions.minWidth > 0 && sizeRestrictions.minHeight > 0) {
        if (aspectRatio > sizeRestrictions.minWidth / sizeRestrictions.minHeight) {
            if (coordinates.height < sizeRestrictions.minHeight) {
                scale = sizeRestrictions.minHeight / coordinates.height;
            }
        }
        else {
            if (coordinates.width < sizeRestrictions.minWidth) {
                scale = sizeRestrictions.minWidth / coordinates.width;
            }
        }
    }
    else if (sizeRestrictions.minWidth > 0) {
        if (coordinates.width < sizeRestrictions.minWidth) {
            scale = sizeRestrictions.minWidth / coordinates.width;
        }
    }
    else if (sizeRestrictions.minHeight > 0) {
        if (coordinates.height < sizeRestrictions.minHeight) {
            scale = sizeRestrictions.minHeight / coordinates.height;
        }
    }
    if (sizeRestrictions.maxWidth < Infinity && sizeRestrictions.maxHeight < Infinity) {
        if (aspectRatio > sizeRestrictions.maxWidth / sizeRestrictions.maxHeight) {
            if (coordinates.width > sizeRestrictions.maxWidth) {
                scale = sizeRestrictions.maxWidth / coordinates.width;
            }
        }
        else {
            if (coordinates.height > sizeRestrictions.maxHeight) {
                scale = sizeRestrictions.maxHeight / coordinates.height;
            }
        }
    }
    else if (sizeRestrictions.maxWidth < Infinity) {
        if (coordinates.width > sizeRestrictions.maxWidth) {
            scale = sizeRestrictions.maxWidth / coordinates.width;
        }
    }
    else if (sizeRestrictions.maxHeight < Infinity) {
        if (coordinates.height > sizeRestrictions.maxHeight) {
            scale = sizeRestrictions.maxHeight / coordinates.height;
        }
    }
    return scale;
}
function getIntersections(object, positionRestrictions) {
    var intersections = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
    };
    ALL_DIRECTIONS.forEach(function (direction) {
        var areaLimit = positionRestrictions[direction];
        var objectLimit = coordinatesToPositionRestrictions(object)[direction];
        if (areaLimit !== undefined && objectLimit !== undefined) {
            if (direction === 'left' || direction === 'top') {
                intersections[direction] = Math.max(0, areaLimit - objectLimit);
            }
            else {
                intersections[direction] = Math.max(0, objectLimit - areaLimit);
            }
        }
        else {
            intersections[direction] = 0;
        }
    });
    return intersections;
}
function resizeToSizeRestrictions(coordinates, sizeRestrictions) {
    return applyScale(coordinates, fitToSizeRestrictions(coordinates, sizeRestrictions));
}
function rotateSize(size, angle) {
    var radians = (angle * Math.PI) / 180;
    return {
        width: Math.abs(size.width * Math.cos(radians)) + Math.abs(size.height * Math.sin(radians)),
        height: Math.abs(size.width * Math.sin(radians)) + Math.abs(size.height * Math.cos(radians)),
    };
}
function rotatePoint(point, angle, anchor) {
    var radians = (angle * Math.PI) / 180;
    if (anchor) {
        return {
            left: (point.left - anchor.left) * Math.cos(radians) -
                (point.top - anchor.top) * Math.sin(radians) +
                anchor.left,
            top: (point.left - anchor.left) * Math.sin(radians) +
                (point.top - anchor.top) * Math.cos(radians) +
                anchor.top,
        };
    }
    else {
        return {
            left: point.left * Math.cos(radians) - point.top * Math.sin(radians),
            top: point.left * Math.sin(radians) + point.top * Math.cos(radians),
        };
    }
}
function positionToSizeRestrictions(positionRestrictions) {
    return {
        minWidth: 0,
        minHeight: 0,
        maxWidth: positionRestrictions.right !== undefined && positionRestrictions.left !== undefined
            ? positionRestrictions.right - positionRestrictions.left
            : Infinity,
        maxHeight: positionRestrictions.bottom !== undefined && positionRestrictions.top !== undefined
            ? positionRestrictions.bottom - positionRestrictions.top
            : Infinity,
    };
}
function mergePositionRestrictions(a, b) {
    var restrictions = {};
    ALL_DIRECTIONS.forEach(function (direction) {
        var firstDirection = a[direction];
        var secondDirection = b[direction];
        if (firstDirection !== undefined && secondDirection !== undefined) {
            if (direction === 'left' || direction === 'top') {
                restrictions[direction] = Math.max(firstDirection, secondDirection);
            }
            else {
                restrictions[direction] = Math.min(firstDirection, secondDirection);
            }
        }
        else if (secondDirection !== undefined) {
            restrictions[direction] = secondDirection;
        }
        else if (firstDirection !== undefined) {
            restrictions[direction] = firstDirection;
        }
    });
    return restrictions;
}
function fitToPositionRestrictions(coordinates, positionRestrictions) {
    var directions = {
        left: 0,
        top: 0,
    };
    var intersection = getIntersections(coordinates, positionRestrictions);
    if (intersection.left && intersection.left > 0) {
        directions.left = intersection.left;
    }
    else if (intersection.right && intersection.right > 0) {
        directions.left = -intersection.right;
    }
    if (intersection.top && intersection.top > 0) {
        directions.top = intersection.top;
    }
    else if (intersection.bottom && intersection.bottom > 0) {
        directions.top = -intersection.bottom;
    }
    return directions;
}
function moveToPositionRestrictions(coordinates, positionRestrictions) {
    return applyMove(coordinates, fitToPositionRestrictions(coordinates, positionRestrictions));
}
function aspectRatioIntersection(main, subset) {
    if (!subset) {
        return main;
    }
    else if (!main) {
        return subset;
    }
    else {
        return {
            minimum: Math.min(main.maximum, Math.max(main.minimum, subset.minimum)),
            maximum: Math.max(main.minimum, Math.min(main.maximum, subset.maximum)),
        };
    }
}
function createAspectRatio(aspectRatio) {
    if (aspectRatio === void 0) { aspectRatio = {}; }
    if (isNumber(aspectRatio)) {
        return {
            minimum: aspectRatio,
            maximum: aspectRatio,
        };
    }
    else {
        return {
            minimum: isNumeric(aspectRatio.minimum) ? aspectRatio.minimum : 0,
            maximum: isNumeric(aspectRatio.maximum) ? aspectRatio.maximum : Infinity,
        };
    }
}
function getTransitionStyle(transitions) {
    return transitions ? transitions.timingFunction + " " + (transitions.active ? transitions.duration : 0) + "ms" : 'none';
}
function isConsistentSize(size, restrictions) {
    return ((isUndefined(restrictions.maxWidth) || !isGreater(size.width, restrictions.maxWidth)) &&
        (isUndefined(restrictions.maxHeight) || !isGreater(size.height, restrictions.maxHeight)) &&
        (isUndefined(restrictions.minHeight) || !isLower(size.height, restrictions.minHeight)) &&
        (isUndefined(restrictions.minWidth) || !isLower(size.width, restrictions.minWidth)));
}
function isConsistentPosition(coordinates, restrictions) {
    return ((isUndefined(restrictions.left) || !isLower(coordinates.left, restrictions.left)) &&
        (isUndefined(restrictions.top) || !isLower(coordinates.top, restrictions.top)) &&
        (isUndefined(restrictions.right) || !isGreater(coordinates.left + coordinates.width, restrictions.right)) &&
        (isUndefined(restrictions.bottom) || !isGreater(coordinates.top + coordinates.height, restrictions.bottom)));
}
function getCloserSize(candidates, reference, sizeRestrictions, aspectRatio) {
    var traverse = function (ignoreMinimum) {
        return candidates.reduce(function (minimum, size) {
            var _a = isFunction(sizeRestrictions)
                ? sizeRestrictions(size)
                : sizeRestrictions, maxHeight = _a.maxHeight, maxWidth = _a.maxWidth, minWidth = _a.minWidth, minHeight = _a.minHeight;
            var preparedAspectRatio = createAspectRatio(isFunction(aspectRatio) ? aspectRatio(size) : aspectRatio);
            var preparedSizeRestrictions = ignoreMinimum
                ? { maxWidth: maxWidth, maxHeight: maxHeight }
                : { maxWidth: maxWidth, maxHeight: maxHeight, minWidth: minWidth, minHeight: minHeight };
            if (isConsistentSize(size, preparedSizeRestrictions) &&
                !getBrokenRatio(ratio(size), preparedAspectRatio) &&
                size.width &&
                size.height) {
                return !minimum || isLower(sizeDistance(size, reference), sizeDistance(minimum, reference))
                    ? size
                    : minimum;
            }
            else {
                return minimum;
            }
        }, null);
    };
    return traverse() || traverse(true);
}

function isInitializedState(state) {
    return Boolean(state && state.visibleArea && state.coordinates);
}
function getAreaSizeRestrictions(state, settings) {
    return calculateAreaSizeRestrictions(state, settings);
}
function getAreaPositionRestrictions(state, settings) {
    return isFunction(settings.areaPositionRestrictions)
        ? settings.areaPositionRestrictions(state, settings)
        : settings.areaPositionRestrictions;
}
function getSizeRestrictions(state, settings) {
    return calculateSizeRestrictions(state, settings);
}
function getPositionRestrictions(state, settings) {
    return isFunction(settings.positionRestrictions)
        ? settings.positionRestrictions(state, settings)
        : settings.positionRestrictions;
}
function getCoefficient(state) {
    return state.visibleArea ? state.visibleArea.width / state.boundary.width : 0;
}
function getStencilCoordinates(state) {
    if (isInitializedState(state)) {
        var _a = state.coordinates, width = _a.width, height = _a.height, left = _a.left, top_1 = _a.top;
        var coefficient = getCoefficient(state);
        return {
            width: width / coefficient,
            height: height / coefficient,
            left: (left - state.visibleArea.left) / coefficient,
            top: (top_1 - state.visibleArea.top) / coefficient,
        };
    }
    else {
        return emptyCoordinates();
    }
}
function getAspectRatio(state, settings) {
    return createAspectRatio(isFunction(settings.aspectRatio) ? settings.aspectRatio(state, settings) : settings.aspectRatio);
}
function getDefaultCoordinates(state, settings) {
    return isFunction(settings.defaultCoordinates)
        ? settings.defaultCoordinates(state, settings)
        : settings.defaultCoordinates;
}
function getDefaultVisibleArea(state, settings) {
    return isFunction(settings.defaultVisibleArea)
        ? settings.defaultVisibleArea(state, settings)
        : settings.defaultVisibleArea;
}
function getTransformedImageSize(state) {
    if (state.imageSize && state.imageSize.width && state.imageSize.height) {
        return rotateSize(state.imageSize, state.transforms.rotate);
    }
    else {
        return {
            width: 0,
            height: 0,
        };
    }
}
function getMinimumSize(state) {
    // The magic number is the approximation of the handler size
    // Temporary solution that should be improved in the future
    return state.coordinates
        ? Math.min(state.coordinates.width, state.coordinates.height, 20 * getCoefficient(state))
        : 1;
}
function getRoundedCoordinates(state, settings) {
    if (isInitializedState(state)) {
        var sizeRestrictions = getSizeRestrictions(state, settings);
        var positionRestrictions = getPositionRestrictions(state, settings);
        var roundCoordinates = {
            width: Math.round(state.coordinates.width),
            height: Math.round(state.coordinates.height),
            left: Math.round(state.coordinates.left),
            top: Math.round(state.coordinates.top),
        };
        if (roundCoordinates.width > sizeRestrictions.maxWidth) {
            roundCoordinates.width = Math.floor(state.coordinates.width);
        }
        else if (roundCoordinates.width < sizeRestrictions.minWidth) {
            roundCoordinates.width = Math.ceil(state.coordinates.width);
        }
        if (roundCoordinates.height > sizeRestrictions.maxHeight) {
            roundCoordinates.height = Math.floor(state.coordinates.height);
        }
        else if (roundCoordinates.height < sizeRestrictions.minHeight) {
            roundCoordinates.height = Math.ceil(state.coordinates.height);
        }
        return moveToPositionRestrictions(roundCoordinates, positionRestrictions);
    }
    else {
        return null;
    }
}
function isConsistentState(state, settings) {
    if (isInitializedState(state)) {
        return (!getBrokenRatio(ratio(state.coordinates), getAspectRatio(state, settings)) &&
            isConsistentSize(state.visibleArea, getAreaSizeRestrictions(state, settings)) &&
            isConsistentSize(state.coordinates, getSizeRestrictions(state, settings)) &&
            isConsistentPosition(state.visibleArea, getAreaPositionRestrictions(state, settings)) &&
            isConsistentPosition(state.coordinates, getPositionRestrictions(state, settings)));
    }
    else {
        return true;
    }
}

function reconcileSizeRestrictions(sizeRestrictions) {
    var restrictions = tslib.__assign({}, sizeRestrictions);
    // Process the border cases when minimum height / width larger than maximum height / width
    if (restrictions.minWidth > restrictions.maxWidth) {
        restrictions.minWidth = restrictions.maxWidth;
    }
    if (restrictions.minHeight > restrictions.maxHeight) {
        restrictions.minHeight = restrictions.maxHeight;
    }
    return restrictions;
}
function mergeSizeRestrictions(a, b) {
    var first = a;
    var second = tslib.__assign({ minWidth: 0, minHeight: 0, maxWidth: Infinity, maxHeight: Infinity }, b);
    return reconcileSizeRestrictions({
        maxHeight: Math.min(first.maxHeight, second.maxHeight),
        minHeight: Math.max(first.minHeight, second.minHeight),
        maxWidth: Math.min(first.maxWidth, second.maxWidth),
        minWidth: Math.max(first.minWidth, second.minWidth),
    });
}
function calculateSizeRestrictions(state, settings) {
    var sizeRestrictions = isFunction(settings.sizeRestrictions)
        ? settings.sizeRestrictions(state, settings)
        : settings.sizeRestrictions;
    var positionRestrictions = getPositionRestrictions(state, settings);
    // User can forget to set some of restrictions, so we should initialize them by default values
    var restrictions = {
        minWidth: isNumeric(sizeRestrictions.minWidth) ? parseNumber(sizeRestrictions.minWidth) : 0,
        minHeight: isNumeric(sizeRestrictions.minHeight) ? parseNumber(sizeRestrictions.minHeight) : 0,
        maxWidth: isNumeric(sizeRestrictions.maxWidth) ? parseNumber(sizeRestrictions.maxWidth) : Infinity,
        maxHeight: isNumeric(sizeRestrictions.maxHeight) ? parseNumber(sizeRestrictions.maxHeight) : Infinity,
    };
    // The situation, when stencil can't be positioned in cropper due to positionRestrictions should be avoided
    if (positionRestrictions.left !== undefined && positionRestrictions.right !== undefined) {
        restrictions.maxWidth = Math.min(restrictions.maxWidth, positionRestrictions.right - positionRestrictions.left);
    }
    if (positionRestrictions.bottom !== undefined && positionRestrictions.top !== undefined) {
        restrictions.maxHeight = Math.min(restrictions.maxHeight, positionRestrictions.bottom - positionRestrictions.top);
    }
    return reconcileSizeRestrictions(restrictions);
}
function calculateAreaSizeRestrictions(state, settings) {
    var sizeRestrictions = isFunction(settings.areaSizeRestrictions)
        ? settings.areaSizeRestrictions(state, settings)
        : settings.areaSizeRestrictions;
    if (sizeRestrictions.maxWidth < Infinity && sizeRestrictions.maxHeight < Infinity) {
        if (ratio(state.boundary) > sizeRestrictions.maxWidth / sizeRestrictions.maxHeight) {
            sizeRestrictions.maxHeight = sizeRestrictions.maxWidth / ratio(state.boundary);
        }
        else {
            sizeRestrictions.maxWidth = sizeRestrictions.maxHeight * ratio(state.boundary);
        }
    }
    return reconcileSizeRestrictions(sizeRestrictions);
}

function copyState(state) {
    return deepClone(state);
}

exports.ImageRestriction = void 0;
(function (ImageRestriction) {
    ImageRestriction["fillArea"] = "fillArea";
    ImageRestriction["fitArea"] = "fitArea";
    ImageRestriction["stencil"] = "stencil";
    ImageRestriction["none"] = "none";
})(exports.ImageRestriction || (exports.ImageRestriction = {}));
exports.Priority = void 0;
(function (Priority) {
    Priority["coordinates"] = "coordinates";
    Priority["visibleArea"] = "visibleArea";
})(exports.Priority || (exports.Priority = {}));

// Limitations:
// 1. Assume that maximum width and height always larger than minimum width and height
// 2. Assume that aspectRatio.minimum < aspectRatio.maximum
// If you break this limitations function could return null!
function approximateSize(params) {
    var width = params.width, height = params.height;
    var sizeRestrictions = params.sizeRestrictions || {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Infinity,
        maxHeight: Infinity,
    };
    var aspectRatio = createAspectRatio(params.aspectRatio);
    var coordinates = {
        width: Math.max(sizeRestrictions.minWidth, Math.min(sizeRestrictions.maxWidth, width)),
        height: Math.max(sizeRestrictions.minHeight, Math.min(sizeRestrictions.maxHeight, height)),
    };
    var candidates = [coordinates];
    if (aspectRatio) {
        [aspectRatio.minimum, aspectRatio.maximum].forEach(function (ratio) {
            if (ratio) {
                candidates.push({ width: coordinates.width, height: coordinates.width / ratio }, { width: coordinates.height * ratio, height: coordinates.height });
            }
        });
    }
    // Resize the candidates as much as possible to prevent breaking minimum size
    candidates = candidates.map(function (candidate) { return resizeToSizeRestrictions(candidate, sizeRestrictions); });
    // TODO: fix the type of return value
    return getCloserSize(candidates, { width: width, height: height }, sizeRestrictions, aspectRatio);
}

function fitVisibleArea(state, settings) {
    var result = copyState(state);
    if (state.visibleArea) {
        var areaSizeRestrictions = getAreaSizeRestrictions(state, settings);
        // Fit the visible area to its size restrictions and boundary aspect ratio:
        result.visibleArea = tslib.__assign(tslib.__assign({}, state.visibleArea), approximateSize({
            width: state.visibleArea.width,
            height: state.visibleArea.height,
            aspectRatio: {
                minimum: ratio(result.boundary),
                maximum: ratio(result.boundary),
            },
            sizeRestrictions: areaSizeRestrictions,
        }));
        // Return the visible area to previous center
        result.visibleArea = applyMove(result.visibleArea, diff(getCenter(state.visibleArea), getCenter(result.visibleArea)));
        // Fit the visible area to positions restrictions
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
    }
    return result;
}

function moveCoordinatesAlgorithm(coordinates, directions, positionRestrictions) {
    var movedCoordinates = applyMove(coordinates, directions);
    return positionRestrictions ? moveToPositionRestrictions(movedCoordinates, positionRestrictions) : movedCoordinates;
}

exports.SetCoordinatesMode = void 0;
(function (SetCoordinatesMode) {
    SetCoordinatesMode["limit"] = "limit";
    SetCoordinatesMode["zoom"] = "zoom";
    SetCoordinatesMode["unsafe"] = "unsafe";
})(exports.SetCoordinatesMode || (exports.SetCoordinatesMode = {}));
function setCoordinates(state, settings, transform, 
// If you set mode to `false`, the coordinates can leave the visible area
mode) {
    if (mode === void 0) { mode = true; }
    var currentMode = mode === false ? exports.SetCoordinatesMode.unsafe : mode === true ? exports.SetCoordinatesMode.zoom : mode;
    var aspectRatio = getAspectRatio(state, settings);
    var sizeRestrictions = getSizeRestrictions(state, settings);
    if (state.visibleArea && currentMode === exports.SetCoordinatesMode.limit) {
        sizeRestrictions = tslib.__assign(tslib.__assign({}, sizeRestrictions), { minWidth: Math.min(state.visibleArea.width, sizeRestrictions.minWidth), minHeight: Math.min(state.visibleArea.height, sizeRestrictions.minHeight), maxWidth: Math.min(state.visibleArea.width, sizeRestrictions.maxWidth), maxHeight: Math.min(state.visibleArea.height, sizeRestrictions.maxHeight) });
    }
    var positionRestrictions = getPositionRestrictions(state, settings);
    if (state.visibleArea && currentMode === exports.SetCoordinatesMode.limit) {
        positionRestrictions = mergePositionRestrictions(positionRestrictions, coordinatesToPositionRestrictions(state.visibleArea));
    }
    var move = function (prevCoordinates, newCoordinates) {
        return moveCoordinatesAlgorithm(prevCoordinates, {
            left: newCoordinates.left - (prevCoordinates.left || 0),
            top: newCoordinates.top - (prevCoordinates.top || 0),
        }, positionRestrictions);
    };
    var resize = function (prevCoordinates, newCoordinates) {
        var coordinates = tslib.__assign(tslib.__assign(tslib.__assign({}, prevCoordinates), approximateSize({
            width: newCoordinates.width,
            height: newCoordinates.height,
            sizeRestrictions: sizeRestrictions,
            aspectRatio: aspectRatio,
        })), { left: 0, top: 0 });
        return move(coordinates, {
            left: prevCoordinates.left || 0,
            top: prevCoordinates.top || 0,
        });
    };
    var coordinates = state.coordinates ? tslib.__assign({}, state.coordinates) : emptyCoordinates();
    var transforms = Array.isArray(transform) ? transform : [transform];
    transforms.forEach(function (transform) {
        var changes;
        if (typeof transform === 'function') {
            changes = transform(tslib.__assign(tslib.__assign({}, state), { coordinates: coordinates }), settings);
        }
        else {
            changes = transform;
        }
        if (changes) {
            if (!isUndefined(changes.width) || !isUndefined(changes.height)) {
                coordinates = resize(coordinates, tslib.__assign(tslib.__assign({}, coordinates), changes));
            }
            if (!isUndefined(changes.left) || !isUndefined(changes.top)) {
                coordinates = move(coordinates, tslib.__assign(tslib.__assign({}, coordinates), changes));
            }
        }
    });
    var result = tslib.__assign(tslib.__assign({}, copyState(state)), { coordinates: coordinates });
    if (result.visibleArea && currentMode === exports.SetCoordinatesMode.zoom) {
        var widthIntersections = Math.max(0, result.coordinates.width - result.visibleArea.width);
        var heightIntersections = Math.max(0, result.coordinates.height - result.visibleArea.height);
        var areaSizeRestrictions = getAreaSizeRestrictions(state, settings);
        var scale = widthIntersections > heightIntersections
            ? result.coordinates.width / result.visibleArea.width
            : result.coordinates.height / result.visibleArea.height;
        if (scale > 1) {
            result.visibleArea = applyScale(result.visibleArea, Math.min(scale, maxScale(result.visibleArea, areaSizeRestrictions)));
        }
        result.visibleArea = applyMove(result.visibleArea, inverseMove(fitToPositionRestrictions(result.coordinates, coordinatesToPositionRestrictions(result.visibleArea))));
        return fitVisibleArea(result, settings);
    }
    else {
        return result;
    }
}

function fitCoordinates(state, settings) {
    if (state.coordinates) {
        var result = copyState(state);
        var aspectRatio = getAspectRatio(state, settings);
        var sizeRestrictions = getSizeRestrictions(state, settings);
        // Fit the size of coordinates to existing size restrictions and visible area
        result.coordinates = tslib.__assign(tslib.__assign({}, state.coordinates), approximateSize({
            width: state.coordinates.width,
            height: state.coordinates.height,
            aspectRatio: aspectRatio,
            sizeRestrictions: state.visibleArea
                ? {
                    maxWidth: Math.min(state.visibleArea.width, sizeRestrictions.maxWidth),
                    maxHeight: Math.min(state.visibleArea.height, sizeRestrictions.maxHeight),
                    minHeight: Math.min(state.visibleArea.height, sizeRestrictions.minHeight),
                    minWidth: Math.min(state.visibleArea.width, sizeRestrictions.minWidth),
                }
                : sizeRestrictions,
        }));
        // Return the coordinates to the previous center
        result.coordinates = applyMove(result.coordinates, diff(getCenter(state.coordinates), getCenter(result.coordinates)));
        // Fit the coordinates to position restrictions and visible area
        result.coordinates = moveToPositionRestrictions(result.coordinates, state.visibleArea
            ? mergePositionRestrictions(coordinatesToPositionRestrictions(state.visibleArea), getPositionRestrictions(result, settings))
            : getPositionRestrictions(result, settings));
        return result;
    }
    return state;
}

function setVisibleArea(state, settings, visibleArea, 
// If you set safe to `false`, the coordinates will be able to leave the visible area
safe) {
    if (safe === void 0) { safe = true; }
    var result = tslib.__assign(tslib.__assign({}, copyState(state)), { visibleArea: visibleArea });
    // There is no possibility to break visible area limitations.
    result = fitVisibleArea(result, settings);
    if (safe) {
        result = fitCoordinates(result, settings);
    }
    return result;
}

function createState(options, settings) {
    var _a, _b;
    var boundary = options.boundary, imageSize = options.imageSize, transforms = options.transforms, priority = options.priority;
    var state = {
        boundary: {
            width: boundary.width,
            height: boundary.height,
        },
        imageSize: {
            width: imageSize.width,
            height: imageSize.height,
        },
        transforms: {
            rotate: (transforms === null || transforms === void 0 ? void 0 : transforms.rotate) || 0,
            flip: {
                horizontal: ((_a = transforms === null || transforms === void 0 ? void 0 : transforms.flip) === null || _a === void 0 ? void 0 : _a.horizontal) || false,
                vertical: ((_b = transforms === null || transforms === void 0 ? void 0 : transforms.flip) === null || _b === void 0 ? void 0 : _b.vertical) || false,
            },
        },
        visibleArea: null,
        coordinates: null,
    };
    if (priority === exports.Priority.visibleArea) {
        state = setVisibleArea(state, settings, getDefaultVisibleArea(state, settings), false);
        state = setCoordinates(state, settings, getDefaultCoordinates(state, settings), exports.SetCoordinatesMode.limit);
    }
    else {
        state = setCoordinates(state, settings, getDefaultCoordinates(state, settings), exports.SetCoordinatesMode.unsafe);
        state = setVisibleArea(state, settings, getDefaultVisibleArea(state, settings), true);
    }
    return state;
}

function moveCoordinates(state, settings, directions) {
    if (isInitializedState(state)) {
        var result = copyState(state);
        result.coordinates = applyMove(result.coordinates, directions);
        result.coordinates = moveToPositionRestrictions(result.coordinates, mergePositionRestrictions(coordinatesToPositionRestrictions(result.visibleArea), getPositionRestrictions(result, settings)));
        return result;
    }
    return state;
}

function fitDirections(_a) {
    var coordinates = _a.coordinates, directions = _a.directions, positionRestrictions = _a.positionRestrictions, sizeRestrictions = _a.sizeRestrictions, preserveRatio = _a.preserveRatio, compensate = _a.compensate;
    var fittedDirections = tslib.__assign({}, directions);
    var currentWidth = applyDirections(coordinates, fittedDirections).width;
    var currentHeight = applyDirections(coordinates, fittedDirections).height;
    // Prevent strange resizes when the width or height of stencil becomes smaller than 0
    if (currentWidth < 0) {
        if (fittedDirections.left < 0 && fittedDirections.right < 0) {
            fittedDirections.left =
                -(coordinates.width - sizeRestrictions.minWidth) / (fittedDirections.left / fittedDirections.right);
            fittedDirections.right =
                -(coordinates.width - sizeRestrictions.minWidth) / (fittedDirections.right / fittedDirections.left);
        }
        else if (fittedDirections.left < 0) {
            fittedDirections.left = -(coordinates.width - sizeRestrictions.minWidth);
        }
        else if (fittedDirections.right < 0) {
            fittedDirections.right = -(coordinates.width - sizeRestrictions.minWidth);
        }
    }
    if (currentHeight < 0) {
        if (fittedDirections.top < 0 && fittedDirections.bottom < 0) {
            fittedDirections.top =
                -(coordinates.height - sizeRestrictions.minHeight) / (fittedDirections.top / fittedDirections.bottom);
            fittedDirections.bottom =
                -(coordinates.height - sizeRestrictions.minHeight) / (fittedDirections.bottom / fittedDirections.top);
        }
        else if (fittedDirections.top < 0) {
            fittedDirections.top = -(coordinates.height - sizeRestrictions.minHeight);
        }
        else if (fittedDirections.bottom < 0) {
            fittedDirections.bottom = -(coordinates.height - sizeRestrictions.minHeight);
        }
    }
    // Prevent breaking limits
    var breaks = getIntersections(applyDirections(coordinates, fittedDirections), positionRestrictions);
    if (compensate) {
        if (breaks.left && breaks.left > 0 && breaks.right === 0) {
            fittedDirections.right += breaks.left;
            fittedDirections.left -= breaks.left;
        }
        else if (breaks.right && breaks.right > 0 && breaks.left === 0) {
            fittedDirections.left += breaks.right;
            fittedDirections.right -= breaks.right;
        }
        if (breaks.top && breaks.top > 0 && breaks.bottom === 0) {
            fittedDirections.bottom += breaks.top;
            fittedDirections.top -= breaks.top;
        }
        else if (breaks.bottom && breaks.bottom > 0 && breaks.top === 0) {
            fittedDirections.top += breaks.bottom;
            fittedDirections.bottom -= breaks.bottom;
        }
        breaks = getIntersections(applyDirections(coordinates, fittedDirections), positionRestrictions);
    }
    var maxResize = {
        width: Infinity,
        height: Infinity,
        left: Infinity,
        right: Infinity,
        top: Infinity,
        bottom: Infinity,
    };
    ALL_DIRECTIONS.forEach(function (direction) {
        var intersection = breaks[direction];
        if (intersection && fittedDirections[direction]) {
            maxResize[direction] = Math.max(0, 1 - intersection / fittedDirections[direction]);
        }
    });
    if (preserveRatio) {
        var multiplier_1 = Math.min.apply(Math, ALL_DIRECTIONS.map(function (direction) { return maxResize[direction]; }));
        if (multiplier_1 !== Infinity) {
            ALL_DIRECTIONS.forEach(function (direction) {
                fittedDirections[direction] *= multiplier_1;
            });
        }
    }
    else {
        ALL_DIRECTIONS.forEach(function (direction) {
            if (maxResize[direction] !== Infinity) {
                fittedDirections[direction] *= maxResize[direction];
            }
        });
    }
    currentWidth = applyDirections(coordinates, fittedDirections).width;
    currentHeight = applyDirections(coordinates, fittedDirections).height;
    if (fittedDirections.right + fittedDirections.left) {
        if (currentWidth > sizeRestrictions.maxWidth) {
            maxResize.width =
                (sizeRestrictions.maxWidth - coordinates.width) / (fittedDirections.right + fittedDirections.left);
        }
        else if (currentWidth < sizeRestrictions.minWidth) {
            maxResize.width =
                (sizeRestrictions.minWidth - coordinates.width) / (fittedDirections.right + fittedDirections.left);
        }
    }
    if (fittedDirections.bottom + fittedDirections.top) {
        if (currentHeight > sizeRestrictions.maxHeight) {
            maxResize.height =
                (sizeRestrictions.maxHeight - coordinates.height) / (fittedDirections.bottom + fittedDirections.top);
        }
        else if (currentHeight < sizeRestrictions.minHeight) {
            maxResize.height =
                (sizeRestrictions.minHeight - coordinates.height) / (fittedDirections.bottom + fittedDirections.top);
        }
    }
    if (preserveRatio) {
        var multiplier_2 = Math.min(maxResize.width, maxResize.height);
        if (multiplier_2 !== Infinity) {
            ALL_DIRECTIONS.forEach(function (direction) {
                fittedDirections[direction] *= multiplier_2;
            });
        }
    }
    else {
        if (maxResize.width !== Infinity) {
            HORIZONTAL_DIRECTIONS$1.forEach(function (direction) {
                fittedDirections[direction] *= maxResize.width;
            });
        }
        if (maxResize.height !== Infinity) {
            VERTICAL_DIRECTIONS$1.forEach(function (direction) {
                fittedDirections[direction] *= maxResize.height;
            });
        }
    }
    return fittedDirections;
}
function distributeOverlap(overlap, first, second) {
    if (isRoughlyEqual(first + second, 0)) {
        return overlap / 2;
    }
    else if (isRoughlyEqual(first, 0)) {
        return 0;
    }
    else if (isRoughlyEqual(second, 0)) {
        return overlap;
    }
    else {
        return overlap * Math.abs(first / (first + second));
    }
}
function resizeCoordinatesAlgorithm(coordinates, directions, options, limitations) {
    var aspectRatio = limitations.aspectRatio, positionRestrictions = limitations.positionRestrictions, sizeRestrictions = limitations.sizeRestrictions;
    var actualCoordinates = tslib.__assign(tslib.__assign({}, coordinates), { right: coordinates.left + coordinates.width, bottom: coordinates.top + coordinates.height });
    directions = tslib.__assign({}, directions);
    var allowedDirections = options.allowedDirections || {
        left: true,
        right: true,
        bottom: true,
        top: true,
    };
    // It's possible that coordinates can be smaller than minimum width or minimum height. In this case
    // corresponding resize should be blocked
    if (coordinates.width < sizeRestrictions.minWidth) {
        directions.left = 0;
        directions.right = 0;
    }
    if (coordinates.height < sizeRestrictions.minHeight) {
        directions.top = 0;
        directions.bottom = 0;
    }
    ALL_DIRECTIONS.forEach(function (direction) {
        if (!allowedDirections[direction]) {
            directions[direction] = 0;
        }
    });
    // 1. First step: determine the safe and desired area
    directions = fitDirections({
        coordinates: actualCoordinates,
        directions: directions,
        sizeRestrictions: sizeRestrictions,
        positionRestrictions: positionRestrictions,
    });
    // 2. Second step: fix desired box to correspondent to aspect ratio
    var currentWidth = applyDirections(actualCoordinates, directions).width;
    var currentHeight = applyDirections(actualCoordinates, directions).height;
    // Checks ratio:
    var ratioBroken = options.preserveAspectRatio
        ? ratio(actualCoordinates)
        : getBrokenRatio(currentWidth / currentHeight, aspectRatio);
    if (ratioBroken) {
        var respectDirection = options.respectDirection;
        if (respectDirection !== 'width' && respectDirection !== 'height') {
            if (actualCoordinates.width >= actualCoordinates.height || ratioBroken === 1) {
                respectDirection = 'width';
            }
            else {
                respectDirection = 'height';
            }
        }
        if (respectDirection === 'width') {
            var overlapHeight = currentWidth / ratioBroken - actualCoordinates.height;
            if (allowedDirections.top && allowedDirections.bottom) {
                var top_1 = directions.top, bottom = directions.bottom;
                directions.bottom = distributeOverlap(overlapHeight, bottom, top_1);
                directions.top = distributeOverlap(overlapHeight, top_1, bottom);
            }
            else if (allowedDirections.bottom) {
                directions.bottom = overlapHeight;
            }
            else if (allowedDirections.top) {
                directions.top = overlapHeight;
            }
            else if (allowedDirections.right) {
                directions.right = 0;
            }
            else if (allowedDirections.left) {
                directions.left = 0;
            }
        }
        else if (respectDirection === 'height') {
            var overlapWidth = actualCoordinates.width - currentHeight * ratioBroken;
            if (allowedDirections.left && allowedDirections.right) {
                var left = directions.left, right = directions.right;
                directions.left = -distributeOverlap(overlapWidth, left, right);
                directions.right = -distributeOverlap(overlapWidth, right, left);
            }
            else if (allowedDirections.left) {
                directions.left = -overlapWidth;
            }
            else if (allowedDirections.right) {
                directions.right = -overlapWidth;
            }
            else if (allowedDirections.top) {
                directions.top = 0;
            }
            else if (allowedDirections.bottom) {
                directions.bottom = 0;
            }
        }
        // 3. Third step: check if desired box with correct aspect ratios break some limits and fit to this conditions
        directions = fitDirections({
            directions: directions,
            coordinates: actualCoordinates,
            sizeRestrictions: sizeRestrictions,
            positionRestrictions: positionRestrictions,
            preserveRatio: true,
            compensate: options.compensate,
        });
    }
    // 4. Check if ratio broken (temporary):
    currentWidth = applyDirections(actualCoordinates, directions).width;
    currentHeight = applyDirections(actualCoordinates, directions).height;
    ratioBroken = options.preserveAspectRatio
        ? ratio(actualCoordinates)
        : getBrokenRatio(currentWidth / currentHeight, aspectRatio);
    if (ratioBroken && Math.abs(ratioBroken - currentWidth / currentHeight) > 1e-3) {
        ALL_DIRECTIONS.forEach(function (direction) {
            if (!allowedDirections[direction]) {
                directions[direction] = 0;
            }
        });
    }
    return moveCoordinatesAlgorithm({
        width: coordinates.width + directions.right + directions.left,
        height: coordinates.height + directions.top + directions.bottom,
        left: coordinates.left,
        top: coordinates.top,
    }, {
        left: -directions.left,
        top: -directions.top,
    }, positionRestrictions);
}

function resizeCoordinates(state, settings, directions, options) {
    var minimumSize = getMinimumSize(state);
    var sizeRestrictions = getSizeRestrictions(state, settings);
    return isInitializedState(state)
        ? tslib.__assign(tslib.__assign({}, copyState(state)), { coordinates: resizeCoordinatesAlgorithm(state.coordinates, directions, options, {
                positionRestrictions: mergePositionRestrictions(getPositionRestrictions(state, settings), coordinatesToPositionRestrictions(state.visibleArea)),
                sizeRestrictions: {
                    maxWidth: Math.min(sizeRestrictions.maxWidth, state.visibleArea.width),
                    maxHeight: Math.min(sizeRestrictions.maxHeight, state.visibleArea.height),
                    minWidth: Math.max(Math.min(sizeRestrictions.minWidth, state.visibleArea.width), minimumSize),
                    minHeight: Math.max(Math.min(sizeRestrictions.minHeight, state.visibleArea.height), minimumSize),
                },
                aspectRatio: getAspectRatio(state, settings),
            }) }) : state;
}

function setBoundary(state, settings, boundary) {
    var result = tslib.__assign(tslib.__assign({}, copyState(state)), { boundary: boundary });
    if (result.visibleArea && result.coordinates && state.visibleArea) {
        // Scale visible area size to fit new boundary:
        result.visibleArea.height = result.visibleArea.width / ratio(boundary);
        result.visibleArea.top += (state.visibleArea.height - result.visibleArea.height) / 2;
        // Scale visible area to prevent overlap coordinates (and its minimum size)
        var sizeRestrictions = getSizeRestrictions(result, settings);
        if (Math.max(sizeRestrictions.minHeight, result.coordinates.height) - result.visibleArea.height > 0 ||
            Math.max(sizeRestrictions.minWidth, result.coordinates.width) - result.visibleArea.width > 0) {
            result.visibleArea = applyScale(result.visibleArea, Math.max(Math.max(sizeRestrictions.minHeight, result.coordinates.height) / result.visibleArea.height, Math.max(sizeRestrictions.minWidth, result.coordinates.width) / result.visibleArea.width));
        }
        // Scale visible area to prevent overlap area restrictions
        result.visibleArea = resizeToSizeRestrictions(result.visibleArea, getAreaSizeRestrictions(result, settings));
        // Move visible are to prevent moving of the coordinates:
        var move = inverseMove(fitToPositionRestrictions(result.coordinates, coordinatesToPositionRestrictions(result.visibleArea)));
        if (result.visibleArea.width < result.coordinates.width) {
            move.left = 0;
        }
        if (result.visibleArea.height < result.coordinates.height) {
            move.top = 0;
        }
        result.visibleArea = applyMove(result.visibleArea, move);
        // Move visible area to prevent overlap the area restrictions
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        result = fitCoordinates(result, settings);
    }
    return result;
}

function rotateImageAlgorithm(state, settings, rotate) {
    if (isInitializedState(state)) {
        var result = copyState(state);
        var angle = isNumber(rotate) ? rotate : rotate.angle;
        var imageCenter = rotatePoint(getCenter(tslib.__assign({ left: 0, top: 0 }, getTransformedImageSize(state))), angle);
        result.transforms.rotate += angle;
        result.coordinates = tslib.__assign(tslib.__assign({}, approximateSize({
            sizeRestrictions: getSizeRestrictions(result, settings),
            aspectRatio: getAspectRatio(result, settings),
            width: result.coordinates.width,
            height: result.coordinates.height,
        })), rotatePoint(getCenter(result.coordinates), angle));
        var center = !isNumber(rotate) && rotate.center ? rotate.center : getCenter(state.coordinates);
        var shift = diff(getCenter(state.coordinates), rotatePoint(getCenter(state.coordinates), angle, center));
        var imageSize = getTransformedImageSize(result);
        result.coordinates.left -= imageCenter.left - imageSize.width / 2 + result.coordinates.width / 2 - shift.left;
        result.coordinates.top -= imageCenter.top - imageSize.height / 2 + result.coordinates.height / 2 - shift.top;
        // Check that visible area doesn't break the area restrictions:
        result.visibleArea = resizeToSizeRestrictions(result.visibleArea, mergeSizeRestrictions(getAreaSizeRestrictions(result, settings), {
            minWidth: result.coordinates.width,
            minHeight: result.coordinates.height,
        }));
        result.coordinates = moveToPositionRestrictions(result.coordinates, getPositionRestrictions(result, settings));
        result.visibleArea = applyMove(result.visibleArea, diff(getCenter(result.coordinates), getCenter(state.coordinates)));
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        return result;
    }
    return state;
}

function flipImageAlgorithm(state, settings, horizontal, vertical) {
    if (isInitializedState(state)) {
        var result = copyState(state);
        var rotate = state.transforms.rotate;
        var imageSize = getTransformedImageSize(state);
        var changed = {
            horizontal: horizontal,
            vertical: vertical,
        };
        if (changed.horizontal || changed.vertical) {
            var imageCenter = rotatePoint({
                left: imageSize.width / 2,
                top: imageSize.height / 2,
            }, -rotate);
            var oldCenter = rotatePoint(getCenter(result.coordinates), -rotate);
            var newCenter = rotatePoint({
                left: changed.horizontal ? imageCenter.left - (oldCenter.left - imageCenter.left) : oldCenter.left,
                top: changed.vertical ? imageCenter.top - (oldCenter.top - imageCenter.top) : oldCenter.top,
            }, rotate);
            result.coordinates = applyMove(result.coordinates, diff(newCenter, getCenter(result.coordinates)));
            oldCenter = rotatePoint(getCenter(result.visibleArea), -rotate);
            newCenter = rotatePoint({
                left: changed.horizontal ? imageCenter.left - (oldCenter.left - imageCenter.left) : oldCenter.left,
                top: changed.vertical ? imageCenter.top - (oldCenter.top - imageCenter.top) : oldCenter.top,
            }, rotate);
            result.visibleArea = applyMove(result.visibleArea, diff(newCenter, getCenter(result.visibleArea)));
            result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        }
        if (changed.horizontal) {
            result.transforms.flip.horizontal = !state.transforms.flip.horizontal;
        }
        if (changed.vertical) {
            result.transforms.flip.vertical = !state.transforms.flip.vertical;
        }
        return result;
    }
    return state;
}

function transformImageAlgorithm(state, settings, transform) {
    var _a;
    var _b = transform.scale, scale = _b === void 0 ? 1 : _b, _c = transform.move, move = _c === void 0 ? {} : _c;
    if (isInitializedState(state)) {
        var result = copyState(state);
        // It's reversed because zooming in the image is actually zooming out visible area
        var scaleFactor = 1 / (isNumber(scale) ? scale : scale.factor);
        var scaleCenter = !isNumber(scale) ? scale.center : undefined;
        var isAllowedScale = !isRoughlyEqual(scaleFactor, 1);
        var areaScale = 1;
        var stencilScale = 1;
        result.visibleArea = applyMove(result.visibleArea, {
            left: move.left || 0,
            top: move.top || 0,
        });
        var sizeRestrictions = getSizeRestrictions(result, settings);
        var positionRestrictions = getPositionRestrictions(result, settings);
        var areaSizeRestrictions = getAreaSizeRestrictions(result, settings);
        var scaleRestrictions = {
            stencil: {
                minimum: Math.max(sizeRestrictions.minWidth ? sizeRestrictions.minWidth / result.coordinates.width : 0, sizeRestrictions.minHeight ? sizeRestrictions.minHeight / result.coordinates.height : 0),
                maximum: Math.min(sizeRestrictions.maxWidth ? sizeRestrictions.maxWidth / result.coordinates.width : Infinity, sizeRestrictions.maxHeight ? sizeRestrictions.maxHeight / result.coordinates.height : Infinity, maxScale(result.coordinates, positionToSizeRestrictions(positionRestrictions))),
            },
            area: {
                maximum: maxScale(result.visibleArea, areaSizeRestrictions),
                minimum: minScale(result.visibleArea, areaSizeRestrictions),
            },
        };
        // If there is scaling then begin scale
        if (scaleFactor && isAllowedScale) {
            // Determine scale factor
            if (scaleFactor < 1) {
                stencilScale = Math.max(scaleFactor, Math.max(scaleRestrictions.area.minimum, scaleRestrictions.stencil.minimum));
                if (stencilScale > 1) {
                    stencilScale = 1;
                }
            }
            else if (scaleFactor > 1) {
                stencilScale = Math.min(scaleFactor, Math.min(scaleRestrictions.area.maximum, scaleRestrictions.stencil.maximum));
                if (stencilScale < 1) {
                    stencilScale = 1;
                }
            }
        }
        if (stencilScale) {
            // Resize stencil with area as much as possible
            result.visibleArea = applyScale(result.visibleArea, stencilScale, scaleCenter);
        }
        var relativeCoordinates = {
            left: state.coordinates.left - state.visibleArea.left,
            right: state.visibleArea.width + state.visibleArea.left - (state.coordinates.width + state.coordinates.left),
            top: state.coordinates.top - state.visibleArea.top,
            bottom: state.visibleArea.height + state.visibleArea.top - (state.coordinates.height + state.coordinates.top),
        };
        // Move the area to fit to the coordinates limits:
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, {
            left: positionRestrictions.left !== undefined
                ? positionRestrictions.left - relativeCoordinates.left * stencilScale
                : undefined,
            top: positionRestrictions.top !== undefined
                ? positionRestrictions.top - relativeCoordinates.top * stencilScale
                : undefined,
            bottom: positionRestrictions.bottom !== undefined
                ? positionRestrictions.bottom + relativeCoordinates.bottom * stencilScale
                : undefined,
            right: positionRestrictions.right !== undefined
                ? positionRestrictions.right + relativeCoordinates.right * stencilScale
                : undefined,
        });
        // But the more important to fit are to the area restrictions, so we should fit it to that restrictions:
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        // Set the same coordinates of stencil inside visible area
        result.coordinates.width = result.coordinates.width * stencilScale;
        result.coordinates.height = result.coordinates.height * stencilScale;
        result.coordinates.left = result.visibleArea.left + relativeCoordinates.left * stencilScale;
        result.coordinates.top = result.visibleArea.top + relativeCoordinates.top * stencilScale;
        // Move the coordinates to prevent the intersection with visible area and position restrictions
        result.coordinates = moveToPositionRestrictions(result.coordinates, mergePositionRestrictions(coordinatesToPositionRestrictions(result.visibleArea), positionRestrictions));
        // Resize only area if stencil can't be resized and stencil resize is disabled
        if (isAllowedScale && scaleFactor && ((_a = settings.transformImage) === null || _a === void 0 ? void 0 : _a.adjustStencil)) {
            if (scaleFactor > 1) {
                areaScale = Math.min(scaleRestrictions.area.maximum, scaleFactor) / stencilScale;
            }
            else if (scaleFactor < 1) {
                areaScale = Math.max(result.coordinates.height / result.visibleArea.height, result.coordinates.width / result.visibleArea.width, scaleFactor / stencilScale);
            }
            if (areaScale !== 1) {
                result.visibleArea = applyScale(result.visibleArea, areaScale, scaleFactor > 1 ? scaleCenter : getCenter(result.coordinates));
                // Move to prevent the breaking of the area restrictions:
                result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
                // Move to prevent the intersection with coordinates:
                result.visibleArea = applyMove(result.visibleArea, inverseMove(fitToPositionRestrictions(result.coordinates, coordinatesToPositionRestrictions(result.visibleArea))));
            }
        }
        return result;
    }
    return state;
}

function transformImage(state, settings, transform) {
    if (transform.rotate) {
        state = rotateImageAlgorithm(state, settings, transform.rotate);
    }
    if (transform.flip) {
        state = flipImageAlgorithm(state, settings, transform.flip.horizontal, transform.flip.vertical);
    }
    if (transform.move || transform.scale) {
        state = transformImageAlgorithm(state, settings, transform);
    }
    return state;
}

function reconcileState(state, settings) {
    if (isInitializedState(state)) {
        var result = copyState(state);
        var aspectRatio = getAspectRatio(state, settings);
        var sizeRestrictions = getSizeRestrictions(state, settings);
        var areaSizeRestrictions = getAreaSizeRestrictions(state, settings);
        // Fit the size of coordinates to existing size restrictions and visible area
        var brokenRatio = getBrokenRatio(ratio(state.coordinates), aspectRatio);
        var desiredSize = brokenRatio
            ? {
                height: state.coordinates.height,
                width: state.coordinates.height * brokenRatio,
            }
            : state.coordinates;
        result.coordinates = tslib.__assign(tslib.__assign({}, result.coordinates), approximateSize({
            width: desiredSize.width,
            height: desiredSize.height,
            aspectRatio: aspectRatio,
            sizeRestrictions: mergeSizeRestrictions(areaSizeRestrictions, sizeRestrictions),
        }));
        // Return the coordinates to the previous center
        result.coordinates = applyMove(result.coordinates, diff(getCenter(state.coordinates), getCenter(result.coordinates)));
        var scaleModifier = Math.max(result.coordinates.width / result.visibleArea.width, result.coordinates.height / result.visibleArea.height, 1);
        // Fit the visible area to its size restrictions and boundary aspect ratio:
        result.visibleArea = tslib.__assign(tslib.__assign({}, state.visibleArea), approximateSize({
            width: state.visibleArea.width * scaleModifier,
            height: state.visibleArea.height * scaleModifier,
            aspectRatio: {
                minimum: ratio(result.boundary),
                maximum: ratio(result.boundary),
            },
            sizeRestrictions: areaSizeRestrictions,
        }));
        // Return the visible area to previous center
        result.visibleArea = applyMove(result.visibleArea, diff(getCenter(state.visibleArea), getCenter(result.visibleArea)));
        // Fit the visible area to positions restrictions
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        // Fit the coordinates to position restrictions and visible area
        result.coordinates = moveToPositionRestrictions(result.coordinates, mergePositionRestrictions(coordinatesToPositionRestrictions(result.visibleArea), getPositionRestrictions(result, settings)));
        return result;
    }
    return state;
}

function normalizeResizeDirections(state, directions) {
    var coefficient = getCoefficient(state);
    return {
        left: isNumber(directions.left) ? directions.left * coefficient : 0,
        top: isNumber(directions.top) ? directions.top * coefficient : 0,
        right: isNumber(directions.right) ? directions.right * coefficient : 0,
        bottom: isNumber(directions.bottom) ? directions.bottom * coefficient : 0,
    };
}
function normalizeCenter(state, center) {
    var coefficient = getCoefficient(state);
    if (state.visibleArea) {
        return {
            left: center.left * coefficient + state.visibleArea.left,
            top: center.top * coefficient + state.visibleArea.top,
        };
    }
    return center;
}
function normalizeFlip(state, flip) {
    if (state) {
        var normalizedAngle = Math.abs(state.transforms.rotate % 180);
        if (normalizedAngle <= 45 || normalizedAngle >= 135) {
            return flip;
        }
        else {
            return {
                horizontal: flip.vertical,
                vertical: flip.horizontal,
            };
        }
    }
    return flip;
}
function fillMoveDirections(directions) {
    return {
        left: isNumber(directions.left) ? directions.left : 0,
        top: isNumber(directions.top) ? directions.top : 0,
    };
}
function fillResizeDirections(directions) {
    return {
        left: isNumber(directions.left) ? directions.left : 0,
        top: isNumber(directions.top) ? directions.top : 0,
        right: isNumber(directions.right) ? directions.right : 0,
        bottom: isNumber(directions.bottom) ? directions.bottom : 0,
    };
}
function normalizeMoveDirections(state, directions) {
    var coefficient = getCoefficient(state);
    return {
        left: isNumber(directions.left) ? directions.left * coefficient : 0,
        top: isNumber(directions.top) ? directions.top * coefficient : 0,
    };
}
function normalizeImageTransform(state, transform) {
    if (transform.scale) {
        transform.scale = {
            factor: isNumber(transform.scale) ? transform.scale : transform.scale.factor,
            center: !isNumber(transform.scale) && transform.scale.center
                ? normalizeCenter(state, transform.scale.center)
                : undefined,
        };
    }
    if (transform.rotate) {
        transform.rotate = {
            angle: isNumber(transform.rotate) ? transform.rotate : transform.rotate.angle,
            center: !isNumber(transform.rotate) && transform.rotate.center
                ? normalizeCenter(state, transform.rotate.center)
                : undefined,
        };
    }
    if (transform.move) {
        transform.move = normalizeMoveDirections(state, transform.move);
    }
    return transform;
}

function calculateGeometricProperties(touches, container) {
    var _a = container.getBoundingClientRect(), left = _a.left, top = _a.top;
    var centerMass = { left: 0, top: 0 };
    var spread = 0;
    touches.forEach(function (touch) {
        centerMass.left += (touch.clientX - left) / touches.length;
        centerMass.top += (touch.clientY - top) / touches.length;
    });
    touches.forEach(function (touch) {
        spread += distance({ left: centerMass.left, top: centerMass.top }, { left: touch.clientX - left, top: touch.clientY - top });
    });
    return { centerMass: centerMass, spread: spread, count: touches.length };
}
function touchesToImageTransform(touches, previousTouches, container, options) {
    if (options === void 0) { options = {}; }
    var move, scale, rotate;
    if (previousTouches.length === 1 && touches.length === 1) {
        if (options.move) {
            move = {
                left: previousTouches[0].clientX - touches[0].clientX,
                top: previousTouches[0].clientY - touches[0].clientY,
            };
        }
    }
    else if (touches.length > 1) {
        var previousProperties = calculateGeometricProperties(previousTouches, container);
        var properties = calculateGeometricProperties(touches, container);
        if (options.rotate && previousTouches.length === 2 && touches.length === 2) {
            var diffs = {
                left: [
                    touches[0].clientX - touches[1].clientX,
                    previousTouches[0].clientX - previousTouches[1].clientX,
                ],
                top: [touches[0].clientY - touches[1].clientY, previousTouches[0].clientY - previousTouches[1].clientY],
            };
            var y = diffs.left[0] * diffs.top[1] - diffs.left[1] * diffs.top[0];
            var x = diffs.left[0] * diffs.left[1] + diffs.top[0] * diffs.top[1];
            if (!isRoughlyEqual(x, 0) && !isRoughlyEqual(y, 0)) {
                var radians = Math.atan2(y, x);
                var angle = -(radians * 180) / Math.PI;
                rotate = {
                    center: properties.centerMass,
                    angle: angle,
                };
            }
        }
        if (options.move) {
            move = {
                left: previousProperties.centerMass.left - properties.centerMass.left,
                top: previousProperties.centerMass.top - properties.centerMass.top,
            };
        }
        if (options.scale) {
            scale = {
                factor: properties.spread / previousProperties.spread,
                center: properties.centerMass,
            };
        }
    }
    return {
        move: move,
        scale: scale,
        rotate: rotate,
    };
}
function wheelEventToImageTransform(event, container, ratio) {
    if (ratio === void 0) { ratio = 0.1; }
    var _a = container.getBoundingClientRect(), left = _a.left, top = _a.top;
    var factor = 1 - ratio * sign((event.deltaY || event.detail || event.wheelDelta));
    var center = {
        left: event.clientX - left,
        top: event.clientY - top,
    };
    return { scale: { factor: factor, center: center } };
}

function isEqualState(a, b) {
    return deepCompare(a, b);
}

function defaultPositionRestrictions(state, settings) {
    var imageSize = getTransformedImageSize(state);
    var limits = {};
    if (settings.imageRestriction && settings.imageRestriction !== 'none') {
        limits = {
            left: 0,
            top: 0,
            right: imageSize.width,
            bottom: imageSize.height,
        };
    }
    return limits;
}

function defaultVisibleArea(state, settings) {
    var coordinates = state.coordinates, boundary = state.boundary;
    var imageSize = getTransformedImageSize(state);
    var boundaryRatio = ratio(boundary);
    if (coordinates) {
        // Visible area will try to fit reference:
        var reference = {
            height: Math.max(coordinates.height, imageSize.height),
            width: Math.max(coordinates.width, imageSize.width),
        };
        var visibleArea = {
            left: 0,
            top: 0,
            width: ratio(reference) > boundaryRatio ? reference.width : reference.height * boundaryRatio,
            height: ratio(reference) > boundaryRatio ? reference.width / boundaryRatio : reference.height,
        };
        // Visible area should correspond its restrictions:
        visibleArea = resizeToSizeRestrictions(visibleArea, getAreaSizeRestrictions(state, settings));
        // Visible area will try to center stencil:
        visibleArea.left = coordinates.left + coordinates.width / 2 - visibleArea.width / 2;
        visibleArea.top = coordinates.top + coordinates.height / 2 - visibleArea.height / 2;
        // TODO: Controversial behavior:
        // If the coordinates are beyond image visible area will be allowed to be beyond image alike:
        var coordinatesIntersection = getIntersections(coordinates, coordinatesToPositionRestrictions(tslib.__assign({ left: 0, top: 0 }, imageSize)));
        var restrictions = {};
        if (!coordinatesIntersection.left && !coordinatesIntersection.right && visibleArea.width <= imageSize.width) {
            restrictions.left = 0;
            restrictions.right = imageSize.width;
        }
        if (!coordinatesIntersection.top && !coordinatesIntersection.bottom && visibleArea.height <= imageSize.height) {
            restrictions.top = 0;
            restrictions.bottom = imageSize.height;
        }
        return moveToPositionRestrictions(visibleArea, restrictions);
    }
    else {
        var imageRatio = ratio(imageSize);
        var areaProperties = {
            height: imageRatio < boundaryRatio ? imageSize.height : imageSize.width / boundaryRatio,
            width: imageRatio < boundaryRatio ? imageSize.height * boundaryRatio : imageSize.width,
        };
        return {
            left: imageSize.width / 2 - areaProperties.width / 2,
            top: imageSize.height / 2 - areaProperties.height / 2,
            width: areaProperties.width,
            height: areaProperties.height,
        };
    }
}

function defaultSize$1(state, settings) {
    var imageSize = state.imageSize, visibleArea = state.visibleArea;
    var sizeRestrictions = getSizeRestrictions(state, settings);
    var aspectRatio = getAspectRatio(state, settings);
    var area;
    if (visibleArea) {
        area = visibleArea;
    }
    else {
        var sizeRestrictions_1 = positionToSizeRestrictions(getPositionRestrictions(state, settings));
        area = {
            width: Math.max(sizeRestrictions_1.minWidth, Math.min(sizeRestrictions_1.maxWidth, imageSize.width)),
            height: Math.max(sizeRestrictions_1.minHeight, Math.min(sizeRestrictions_1.maxHeight, imageSize.height)),
        };
    }
    var optimalRatio = Math.min(aspectRatio.maximum || Infinity, Math.max(aspectRatio.minimum || 0, ratio(area)));
    var size = area.width < area.height
        ? {
            width: area.width * 0.8,
            height: (area.width * 0.8) / optimalRatio,
        }
        : {
            height: area.height * 0.8,
            width: area.height * 0.8 * optimalRatio,
        };
    return approximateSize(tslib.__assign(tslib.__assign({}, size), { aspectRatio: aspectRatio, sizeRestrictions: sizeRestrictions }));
}

function retrieveSizeRestrictions(settings) {
    return {
        minWidth: isNumeric(settings.minWidth) ? parseNumber(settings.minWidth) : 0,
        minHeight: isNumeric(settings.minHeight) ? parseNumber(settings.minHeight) : 0,
        maxWidth: isNumeric(settings.maxWidth) ? parseNumber(settings.maxWidth) : Infinity,
        maxHeight: isNumeric(settings.maxHeight) ? parseNumber(settings.maxHeight) : Infinity,
    };
}
function pixelsRestrictions(state, settings) {
    return retrieveSizeRestrictions(settings);
}

function defaultPosition(state) {
    var visibleArea = state.visibleArea, coordinates = state.coordinates;
    var area = visibleArea || getTransformedImageSize(state);
    return {
        left: (visibleArea ? visibleArea.left : 0) + area.width / 2 - (coordinates ? coordinates.width / 2 : 0),
        top: (visibleArea ? visibleArea.top : 0) + area.height / 2 - (coordinates ? coordinates.height / 2 : 0),
    };
}

function defaultAreaPositionRestrictions(state, settings) {
    var visibleArea = state.visibleArea, boundary = state.boundary;
    var imageRestriction = settings.imageRestriction;
    var imageSize = getTransformedImageSize(state);
    var restrictions = {};
    if (imageRestriction === exports.ImageRestriction.fillArea) {
        restrictions = {
            left: 0,
            top: 0,
            right: imageSize.width,
            bottom: imageSize.height,
        };
    }
    else if (imageRestriction === exports.ImageRestriction.fitArea) {
        if (ratio(boundary) > ratio(imageSize)) {
            restrictions = {
                top: 0,
                bottom: imageSize.height,
            };
            if (visibleArea) {
                if (visibleArea.width > imageSize.width) {
                    restrictions.left = -(visibleArea.width - imageSize.width) / 2;
                    restrictions.right = imageSize.width - restrictions.left;
                }
                else {
                    restrictions.left = 0;
                    restrictions.right = imageSize.width;
                }
            }
        }
        else {
            restrictions = {
                left: 0,
                right: imageSize.width,
            };
            if (visibleArea) {
                if (visibleArea.height > imageSize.height) {
                    restrictions.top = -(visibleArea.height - imageSize.height) / 2;
                    restrictions.bottom = imageSize.height - restrictions.top;
                }
                else {
                    restrictions.top = 0;
                    restrictions.bottom = imageSize.height;
                }
            }
        }
    }
    return restrictions;
}

function defaultAreaSizeRestrictions(state, settings) {
    var boundary = state.boundary;
    var imageRestriction = settings.imageRestriction;
    var imageSize = getTransformedImageSize(state);
    var restrictions = {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Infinity,
        maxHeight: Infinity,
    };
    if (imageRestriction === exports.ImageRestriction.fillArea) {
        restrictions.maxWidth = imageSize.width;
        restrictions.maxHeight = imageSize.height;
    }
    else if (imageRestriction === exports.ImageRestriction.fitArea) {
        if (ratio(boundary) > ratio(imageSize)) {
            restrictions.maxHeight = imageSize.height;
            restrictions.maxWidth = imageSize.height * ratio(boundary);
        }
        else {
            restrictions.maxWidth = imageSize.width;
            restrictions.maxHeight = imageSize.width / ratio(boundary);
        }
    }
    return restrictions;
}

function fitBoundary(boundary, size) {
    var areaHeight = boundary.clientHeight;
    var areaWidth = boundary.clientWidth;
    var currentHeight = areaHeight;
    var currentWidth = (size.width * areaHeight) / size.height;
    if (currentWidth > areaWidth) {
        currentWidth = areaWidth;
        currentHeight = (size.height * areaWidth) / size.width;
    }
    return {
        width: currentWidth,
        height: currentHeight,
    };
}
function fillBoundary(boundary) {
    return {
        width: boundary.clientWidth,
        height: boundary.clientHeight,
    };
}

function defaultStencilConstraints(rawSettings, stencilProps) {
    if (!rawSettings.aspectRatio) {
        return {
            aspectRatio: createAspectRatio(isFunction(stencilProps.aspectRatio) ? stencilProps.aspectRatio() : stencilProps.aspectRatio),
        };
    }
    return {};
}

function withDefaultSizeRestrictions(sizeRestrictions) {
    return function (state, basicSettings) {
        var value = isFunction(sizeRestrictions) ? sizeRestrictions(state, basicSettings) : sizeRestrictions;
        return mergeSizeRestrictions(pixelsRestrictions(state, basicSettings), value);
    };
}
function withDefaultPositionRestrictions(positionRestrictions) {
    return function (state, basicSettings) {
        var value = isFunction(positionRestrictions)
            ? positionRestrictions(state, basicSettings)
            : positionRestrictions;
        return mergePositionRestrictions(defaultPositionRestrictions(state, basicSettings), value);
    };
}
function withDefaultAreaPositionRestrictions(areaPositionRestrictions) {
    return function (state, basicSettings) {
        var value = isFunction(areaPositionRestrictions)
            ? areaPositionRestrictions(state, basicSettings)
            : areaPositionRestrictions;
        return mergePositionRestrictions(defaultAreaPositionRestrictions(state, basicSettings), value);
    };
}
function withDefaultAreaSizeRestrictions(areaSizeRestrictions) {
    return function (state, basicSettings) {
        var value = isFunction(areaSizeRestrictions)
            ? areaSizeRestrictions(state, basicSettings)
            : areaSizeRestrictions;
        return mergeSizeRestrictions(defaultAreaSizeRestrictions(state, basicSettings), value);
    };
}
function createDefaultSettings(params) {
    return tslib.__assign(tslib.__assign({}, params), { sizeRestrictions: function (state, basicSettings) {
            var restrictions;
            if (params.sizeRestrictions) {
                restrictions = isFunction(params.sizeRestrictions)
                    ? params.sizeRestrictions(state, basicSettings)
                    : params.sizeRestrictions;
            }
            else {
                restrictions = pixelsRestrictions(state, basicSettings);
            }
            return restrictions;
        }, areaPositionRestrictions: function (state, basicSettings) {
            if (params.areaPositionRestrictions) {
                return isFunction(params.areaPositionRestrictions)
                    ? params.areaPositionRestrictions(state, basicSettings)
                    : params.areaPositionRestrictions;
            }
            else {
                return defaultAreaPositionRestrictions(state, basicSettings);
            }
        }, areaSizeRestrictions: function (state, basicSettings) {
            if (params.areaSizeRestrictions) {
                return isFunction(params.areaSizeRestrictions)
                    ? params.areaSizeRestrictions(state, basicSettings)
                    : params.areaSizeRestrictions;
            }
            else {
                return defaultAreaSizeRestrictions(state, basicSettings);
            }
        }, positionRestrictions: function (state, basicSettings) {
            if (params.positionRestrictions) {
                return isFunction(params.positionRestrictions)
                    ? params.positionRestrictions(state, basicSettings)
                    : params.positionRestrictions;
            }
            else {
                return defaultPositionRestrictions(state, basicSettings);
            }
        }, defaultCoordinates: function (state, basicSettings) {
            if (params.defaultCoordinates) {
                return isFunction(params.defaultCoordinates)
                    ? params.defaultCoordinates(state, basicSettings)
                    : params.defaultCoordinates;
            }
            else {
                var defaultSizeAlgorithm = params.defaultSize;
                if (!defaultSizeAlgorithm) {
                    defaultSizeAlgorithm = defaultSize$1;
                }
                var size = isFunction(defaultSizeAlgorithm)
                    ? defaultSizeAlgorithm(state, basicSettings)
                    : defaultSizeAlgorithm;
                var defaultPositionAlgorithm_1 = params.defaultPosition || defaultPosition;
                return [
                    size,
                    function (state) { return (tslib.__assign({}, (isFunction(defaultPositionAlgorithm_1)
                        ? defaultPositionAlgorithm_1(state, basicSettings)
                        : defaultPositionAlgorithm_1))); },
                ];
            }
        }, defaultVisibleArea: function (state, basicSettings) {
            if (params.defaultVisibleArea) {
                return isFunction(params.defaultVisibleArea)
                    ? params.defaultVisibleArea(state, basicSettings)
                    : params.defaultVisibleArea;
            }
            else {
                return defaultVisibleArea(state, basicSettings);
            }
        }, aspectRatio: function (state, basicSettings) {
            return createAspectRatio(isFunction(params.aspectRatio) ? params.aspectRatio(state, basicSettings) : params.aspectRatio);
        } });
}

function hasInteractions(interactions) {
    return (interactions.moveCoordinates ||
        interactions.resizeCoordinates ||
        interactions.transformImage.move ||
        interactions.transformImage.rotate ||
        interactions.transformImage.flip ||
        interactions.transformImage.scale);
}
function emptyInteractions() {
    return {
        moveCoordinates: false,
        resizeCoordinates: false,
        transformImage: {
            rotate: false,
            move: false,
            scale: false,
            flip: false,
        },
    };
}

function runCallback(callback, getInstance) {
    if (callback && getInstance) {
        var instance = getInstance();
        if (instance) {
            callback(instance);
        }
    }
}
function createCallback(callback, getInstance) {
    return function () {
        runCallback(callback, getInstance);
    };
}
function runCallbacks(callbacks) {
    callbacks.forEach(function (callback) {
        callback();
    });
}
var AbstractCropper$1 = /** @class */ (function () {
    function AbstractCropper() {
        var _this = this;
        this.getTransitions = function () {
            var data = _this.getData();
            var transitions = _this.getProps().transitions;
            return tslib.__assign(tslib.__assign({}, getOptions(transitions, {
                timingFunction: 'ease-in-out',
                duration: 350,
            })), { active: data.transitions });
        };
        this.getInteractions = function () {
            var interactions = _this.getData().interactions;
            return deepClone(interactions);
        };
        this.hasInteractions = function () {
            var interactions = _this.getData().interactions;
            return hasInteractions(interactions);
        };
        this.disableTransitions = debounce(function () {
            var _a = _this.getProps(), onTransitionsEnd = _a.onTransitionsEnd, getInstance = _a.getInstance;
            _this.setData(tslib.__assign(tslib.__assign({}, _this.getData()), { transitions: false }));
            runCallback(onTransitionsEnd, getInstance);
        }, function () {
            return _this.getTransitions().duration;
        });
        this.applyPostProcess = function (action, state) {
            var _a = _this.getProps(), settings = _a.settings, postProcess = _a.postProcess;
            var name = action.name, _b = action.interaction, interaction = _b === void 0 ? false : _b, _c = action.transitions, transitions = _c === void 0 ? false : _c, _d = action.immediately, immediately = _d === void 0 ? false : _d;
            var preparedAction = {
                name: name,
                interaction: interaction,
                transitions: transitions,
                immediately: immediately,
            };
            if (isArray(postProcess)) {
                return postProcess.reduce(function (processedState, p) { return p(processedState, settings, preparedAction); }, state);
            }
            else if (isFunction(postProcess)) {
                return postProcess(state, settings, preparedAction);
            }
            else {
                return state;
            }
        };
        this.updateState = function (modifier, options, callbacks) {
            if (options === void 0) { options = {}; }
            if (callbacks === void 0) { callbacks = []; }
            var _a = options.transitions, transitions = _a === void 0 ? false : _a;
            var _b = _this.getProps(), onTransitionsStart = _b.onTransitionsStart, getInstance = _b.getInstance, onChange = _b.onChange, settings = _b.settings;
            var previousData = _this.getData();
            var state = isFunction(modifier) ? modifier(previousData.state, settings) : modifier;
            var tolerance = state ? 1e-3 * getCoefficient(state) : 1e-3;
            var somethingChanged = !deepCompare(previousData.state, state, tolerance);
            var affectTransitionProperties = [
                'coordinates',
                'boundary',
                'visibleArea',
                'imageSize',
                'transforms',
            ].some(function (property) { var _a; return !deepCompare((_a = previousData.state) === null || _a === void 0 ? void 0 : _a[property], state === null || state === void 0 ? void 0 : state[property], tolerance); });
            var currentData = previousData;
            if (somethingChanged) {
                if (transitions && affectTransitionProperties) {
                    _this.disableTransitions();
                }
                currentData = tslib.__assign(tslib.__assign({}, currentData), { state: copyState(state), transitions: transitions && affectTransitionProperties });
                _this.setData(currentData);
                runCallback(onChange, getInstance);
            }
            if (currentData.transitions && !previousData.transitions) {
                runCallback(onTransitionsStart, getInstance);
            }
            runCallbacks(callbacks.map(function (callback) { return createCallback(callback, getInstance); }));
        };
        this.setInteractions = function (interactions) {
            var _a = _this.getProps(), onInteractionStart = _a.onInteractionStart, onInteractionEnd = _a.onInteractionEnd, getInstance = _a.getInstance;
            var previousInteractions = _this.getInteractions();
            var currentInteractions = tslib.__assign(tslib.__assign({}, previousInteractions), interactions);
            if (!deepCompare(previousInteractions, currentInteractions)) {
                _this.setData(tslib.__assign(tslib.__assign({}, _this.getData()), { interactions: currentInteractions }));
            }
            if (hasInteractions(previousInteractions) !== hasInteractions(currentInteractions)) {
                if (!hasInteractions(previousInteractions)) {
                    runCallback(onInteractionStart, getInstance);
                }
                else {
                    var state_1 = _this.getData().state;
                    _this.updateState(function () {
                        return state_1 &&
                            _this.applyPostProcess({
                                name: 'interactionEnd',
                                immediately: true,
                                transitions: true,
                            }, state_1);
                    }, {
                        transitions: true,
                    }, [onInteractionEnd]);
                }
            }
        };
        this.resetState = function (boundary, image) {
            _this.updateState(_this.createDefaultState(boundary, image));
        };
        this.clear = function () {
            _this.updateState(null);
        };
        this.reconcileState = function (options) {
            if (options === void 0) { options = {}; }
            var _a = _this.getProps(), reconcileStateAlgorithm = _a.reconcileStateAlgorithm, settings = _a.settings;
            var state = _this.getData().state;
            var _b = options.transitions, transitions = _b === void 0 ? false : _b;
            if (state && !isConsistentState(state, settings)) {
                var reconciledState = (reconcileStateAlgorithm || reconcileState)(state, settings);
                reconciledState = _this.applyPostProcess({
                    name: 'reconcileState',
                    immediately: true,
                    transitions: transitions,
                }, reconciledState);
                _this.updateState(reconciledState, {
                    transitions: transitions,
                });
            }
        };
        this.transformImage = function (transform, options) {
            if (options === void 0) { options = {}; }
            var _a = options.transitions, transitions = _a === void 0 ? true : _a, _b = options.interaction, interaction = _b === void 0 ? true : _b, _c = options.immediately, immediately = _c === void 0 ? false : _c, _d = options.normalize, normalize = _d === void 0 ? true : _d;
            var _e = _this.getProps(), transformImageAlgorithm = _e.transformImageAlgorithm, onTransformImage = _e.onTransformImage, onTransformImageEnd = _e.onTransformImageEnd, settings = _e.settings;
            var state = _this.getData().state;
            var callbacks = [];
            if (state) {
                if (normalize) {
                    transform = normalizeImageTransform(state, transform);
                }
                var result = _this.applyPostProcess({
                    name: 'transformImage',
                    transitions: transitions,
                    immediately: immediately,
                }, (transformImageAlgorithm || transformImage)(state, settings, transform));
                callbacks.push(onTransformImage);
                if (interaction) {
                    _this.setInteractions({
                        transformImage: {
                            rotate: !isUndefined(transform.rotate),
                            flip: !isUndefined(transform.flip),
                            scale: !isUndefined(transform.scale),
                            move: !isUndefined(transform.move),
                        },
                    });
                }
                else {
                    result = _this.applyPostProcess({
                        name: 'transformImageEnd',
                        transitions: transitions,
                        immediately: true,
                    }, result);
                    callbacks.push(onTransformImageEnd);
                }
                _this.updateState(result, {
                    transitions: immediately && transitions,
                }, callbacks);
            }
        };
        this.transformImageEnd = function (options) {
            if (options === void 0) { options = {}; }
            var _a = options.immediately, immediately = _a === void 0 ? true : _a, _b = options.transitions, transitions = _b === void 0 ? true : _b;
            var state = _this.getData().state;
            var onTransformImageEnd = _this.getProps().onTransformImageEnd;
            _this.updateState(function () { return state && _this.applyPostProcess({ name: 'transformImageEnd', immediately: immediately, transitions: transitions }, state); }, {
                transitions: transitions,
            }, [onTransformImageEnd]);
            _this.setInteractions({
                transformImage: {
                    rotate: false,
                    flip: false,
                    scale: false,
                    move: false,
                },
            });
        };
        this.zoomImage = function (scale, options) {
            if (options === void 0) { options = {}; }
            var _a = options.interaction, interaction = _a === void 0 ? false : _a, _b = options.immediately, immediately = _b === void 0 ? true : _b, _c = options.transitions, transitions = _c === void 0 ? true : _c, _d = options.normalize, normalize = _d === void 0 ? false : _d;
            _this.transformImage({
                scale: scale,
            }, { interaction: interaction, immediately: immediately, transitions: transitions, normalize: normalize });
        };
        this.moveImage = function (left, top, options) {
            if (options === void 0) { options = {}; }
            var _a = options.interaction, interaction = _a === void 0 ? false : _a, _b = options.immediately, immediately = _b === void 0 ? true : _b, _c = options.transitions, transitions = _c === void 0 ? true : _c, _d = options.normalize, normalize = _d === void 0 ? false : _d;
            _this.transformImage({
                move: {
                    left: left,
                    top: top,
                },
            }, { interaction: interaction, immediately: immediately, transitions: transitions, normalize: normalize });
        };
        this.flipImage = function (horizontal, vertical, options) {
            if (options === void 0) { options = {}; }
            var _a = options.interaction, interaction = _a === void 0 ? false : _a, _b = options.immediately, immediately = _b === void 0 ? true : _b, _c = options.transitions, transitions = _c === void 0 ? true : _c, _d = options.normalize, normalize = _d === void 0 ? true : _d;
            var state = _this.getState();
            var flip = {
                horizontal: horizontal,
                vertical: vertical,
            };
            _this.transformImage({
                flip: state && normalize ? normalizeFlip(state, flip) : flip,
            }, { interaction: interaction, immediately: immediately, transitions: transitions });
        };
        this.rotateImage = function (rotate, options) {
            if (options === void 0) { options = {}; }
            var _a = options.interaction, interaction = _a === void 0 ? false : _a, _b = options.immediately, immediately = _b === void 0 ? true : _b, _c = options.transitions, transitions = _c === void 0 ? true : _c, _d = options.normalize, normalize = _d === void 0 ? false : _d;
            _this.transformImage({
                rotate: rotate,
            }, { interaction: interaction, immediately: immediately, transitions: transitions, normalize: normalize });
        };
        this.reset = function (boundary, image) {
            _this.resetState(boundary, image);
        };
        this.setState = function (modifier, options) {
            if (options === void 0) { options = {}; }
            var settings = _this.getSettings();
            var state = _this.getData().state;
            var _a = options.transitions, transitions = _a === void 0 ? true : _a, _b = options.immediately, immediately = _b === void 0 ? false : _b, _c = options.interaction, interaction = _c === void 0 ? false : _c, _d = options.postprocess, postprocess = _d === void 0 ? false : _d;
            var newState = modifier && (isFunction(modifier) ? modifier(state, settings) : tslib.__assign(tslib.__assign({}, state), modifier));
            _this.updateState(function () {
                return postprocess
                    ? newState &&
                        _this.applyPostProcess({
                            name: 'setState',
                            immediately: immediately,
                            transitions: transitions,
                            interaction: interaction,
                        }, newState)
                    : newState;
            }, {
                transitions: transitions,
            });
        };
        this.setCoordinates = function (transforms, options) {
            if (options === void 0) { options = {}; }
            var state = _this.getData().state;
            var _a = _this.getProps(), setCoordinatesAlgorithm = _a.setCoordinatesAlgorithm, settings = _a.settings;
            var _b = options.transitions, transitions = _b === void 0 ? true : _b, _c = options.immediately, immediately = _c === void 0 ? true : _c;
            _this.updateState(function () {
                return state &&
                    _this.applyPostProcess({
                        name: 'setCoordinates',
                        immediately: immediately,
                        transitions: transitions,
                    }, (setCoordinatesAlgorithm || setCoordinates)(state, settings, transforms, exports.SetCoordinatesMode.zoom));
            }, {
                transitions: transitions,
            });
        };
        this.setVisibleArea = function (visibleArea, options) {
            if (options === void 0) { options = {}; }
            var _a = options.transitions, transitions = _a === void 0 ? true : _a, _b = options.immediately, immediately = _b === void 0 ? true : _b;
            var state = _this.getData().state;
            var _c = _this.getProps(), setVisibleAreaAlgorithm = _c.setVisibleAreaAlgorithm, settings = _c.settings;
            _this.updateState(function () {
                return state &&
                    _this.applyPostProcess({ name: 'setVisibleArea', immediately: immediately, transitions: transitions }, (setVisibleAreaAlgorithm || setVisibleArea)(state, settings, visibleArea));
            }, {
                transitions: transitions,
            });
        };
        this.setBoundary = function (boundary, options) {
            if (options === void 0) { options = {}; }
            var state = _this.getData().state;
            var _a = _this.getProps(), setBoundaryAlgorithm = _a.setBoundaryAlgorithm, settings = _a.settings;
            var _b = options.transitions, transitions = _b === void 0 ? false : _b, _c = options.immediately, immediately = _c === void 0 ? true : _c;
            if (boundary) {
                _this.updateState(function () {
                    return state &&
                        _this.applyPostProcess({ name: 'setBoundary', immediately: immediately, transitions: transitions }, (setBoundaryAlgorithm || setBoundary)(state, settings, boundary));
                });
            }
            else {
                _this.updateState(null);
            }
        };
        this.moveCoordinates = function (directions, options) {
            if (options === void 0) { options = {}; }
            var data = _this.getData();
            var _a = _this.getProps(), moveCoordinatesAlgorithm = _a.moveCoordinatesAlgorithm, onMove = _a.onMove, onMoveEnd = _a.onMoveEnd, settings = _a.settings;
            var _b = options.interaction, interaction = _b === void 0 ? true : _b, _c = options.transitions, transitions = _c === void 0 ? false : _c, _d = options.immediately, immediately = _d === void 0 ? false : _d, _e = options.normalize, normalize = _e === void 0 ? true : _e;
            var callbacks = [];
            if (!data.transitions && data.state) {
                var normalizedDirections = normalize
                    ? normalizeMoveDirections(data.state, directions)
                    : fillMoveDirections(directions);
                var result = _this.applyPostProcess({ name: 'moveCoordinates', interaction: interaction, immediately: immediately, transitions: transitions }, (moveCoordinatesAlgorithm || moveCoordinates)(data.state, settings, normalizedDirections));
                callbacks.push(onMove);
                if (interaction) {
                    _this.setInteractions({
                        moveCoordinates: true,
                    });
                }
                else {
                    result = _this.applyPostProcess({ name: 'moveCoordinatesEnd', interaction: interaction, immediately: immediately, transitions: transitions }, result);
                    callbacks.push(onMoveEnd);
                }
                _this.updateState(result, {
                    transitions: immediately && transitions,
                }, callbacks);
            }
        };
        this.moveCoordinatesEnd = function (options) {
            if (options === void 0) { options = {}; }
            var state = _this.getData().state;
            var onMoveEnd = _this.getProps().onMoveEnd;
            var _a = options.transitions, transitions = _a === void 0 ? true : _a, _b = options.immediately, immediately = _b === void 0 ? false : _b;
            _this.updateState(function () { return state && _this.applyPostProcess({ name: 'moveCoordinatesEnd', transitions: transitions, immediately: immediately }, state); }, {
                transitions: transitions,
            }, [onMoveEnd]);
            _this.setInteractions({
                moveCoordinates: false,
            });
        };
        this.resizeCoordinates = function (directions, parameters, options) {
            if (parameters === void 0) { parameters = {}; }
            if (options === void 0) { options = {}; }
            var state = _this.getData().state;
            var _a = _this.getProps(), resizeCoordinatesAlgorithm = _a.resizeCoordinatesAlgorithm, onResize = _a.onResize, onResizeEnd = _a.onResizeEnd, settings = _a.settings;
            var _b = options.interaction, interaction = _b === void 0 ? true : _b, _c = options.transitions, transitions = _c === void 0 ? false : _c, _d = options.immediately, immediately = _d === void 0 ? false : _d, _e = options.normalize, normalize = _e === void 0 ? true : _e;
            var transitionsOptions = _this.getTransitions();
            if (!transitionsOptions.active && state) {
                var callbacks = [];
                var normalizedDirections = normalize
                    ? normalizeResizeDirections(state, directions)
                    : fillResizeDirections(directions);
                var result = _this.applyPostProcess({ name: 'resizeCoordinates', interaction: interaction, immediately: immediately, transitions: transitions }, (resizeCoordinatesAlgorithm || resizeCoordinates)(state, settings, normalizedDirections, parameters));
                callbacks.push(onResize);
                if (interaction) {
                    _this.setInteractions({
                        resizeCoordinates: true,
                    });
                }
                else {
                    result = _this.applyPostProcess({ name: 'resizeCoordinatesEnd', interaction: interaction, immediately: immediately, transitions: transitions }, result);
                    callbacks.push(onResizeEnd);
                }
                _this.updateState(result, {
                    transitions: immediately && transitions,
                }, callbacks);
            }
        };
        this.resizeCoordinatesEnd = function (options) {
            if (options === void 0) { options = {}; }
            var onResizeEnd = _this.getProps().onResizeEnd;
            var state = _this.getData().state;
            var _a = options.transitions, transitions = _a === void 0 ? true : _a, _b = options.immediately, immediately = _b === void 0 ? false : _b;
            _this.updateState(function () { return state && _this.applyPostProcess({ name: 'resizeCoordinatesEnd', transitions: transitions, immediately: immediately }, state); }, {
                transitions: transitions,
            }, [onResizeEnd]);
            _this.setInteractions({
                resizeCoordinates: false,
            });
        };
        this.getStencilCoordinates = function () {
            var state = _this.getData().state;
            return getStencilCoordinates(state);
        };
        this.getCoordinates = function (options) {
            if (options === void 0) { options = {}; }
            var state = _this.getData().state;
            var settings = _this.getProps().settings;
            if (state && state.coordinates) {
                var _a = options.round, round = _a === void 0 ? true : _a;
                if (round) {
                    return getRoundedCoordinates(state, settings);
                }
                else {
                    return tslib.__assign({}, state.coordinates);
                }
            }
            else {
                return null;
            }
        };
        this.getVisibleArea = function () {
            var state = _this.getData().state;
            if (state) {
                return tslib.__assign({}, state.visibleArea);
            }
            else {
                return null;
            }
        };
        this.getSettings = function () {
            var settings = _this.getProps().settings;
            return tslib.__assign({}, settings);
        };
        this.getState = function () {
            var state = _this.getData().state;
            return copyState(state);
        };
        this.getTransforms = function () {
            var state = _this.getData().state;
            return state
                ? deepClone(state.transforms)
                : {
                    rotate: 0,
                    flip: {
                        horizontal: false,
                        vertical: false,
                    },
                };
        };
        this.createDefaultState = function (boundary, image) {
            var _a = _this.getProps(), defaultTransforms = _a.defaultTransforms, createStateAlgorithm = _a.createStateAlgorithm, priority = _a.priority, settings = _a.settings;
            var transforms = image.transforms;
            if (defaultTransforms) {
                transforms = isFunction(defaultTransforms) ? defaultTransforms(image) : defaultTransforms;
            }
            return _this.applyPostProcess({
                name: 'createState',
                immediately: true,
                transitions: false,
            }, (createStateAlgorithm || createState)({
                boundary: boundary,
                imageSize: { width: image.width, height: image.height },
                transforms: transforms,
                priority: priority,
            }, settings));
        };
        this.isConsistent = function () {
            var state = _this.getData().state;
            var settings = _this.getProps().settings;
            return state ? isConsistentState(state, settings) : true;
        };
    }
    return AbstractCropper;
}());

var CropperInstance = /** @class */ (function (_super) {
    tslib.__extends(CropperInstance, _super);
    function CropperInstance(props) {
        var _this = _super.call(this) || this;
        _this.props = props;
        if (!_this.isControlled()) {
            _this.data = {
                state: null,
                transitions: false,
                interactions: emptyInteractions(),
            };
        }
        return _this;
    }
    CropperInstance.prototype.isControlled = function () {
        return Boolean(this.props.getData);
    };
    CropperInstance.prototype.setData = function (data) {
        var _a, _b;
        if (!this.isControlled()) {
            this.data = data;
        }
        (_b = (_a = this.props).setData) === null || _b === void 0 ? void 0 : _b.call(_a, data);
    };
    CropperInstance.prototype.getProps = function () {
        return this.props.getProps();
    };
    CropperInstance.prototype.getData = function () {
        var _a, _b;
        return (this.isControlled() ? (_b = (_a = this.props).getData) === null || _b === void 0 ? void 0 : _b.call(_a) : this.data);
    };
    return CropperInstance;
}(AbstractCropper$1));

var timingFunctions = {
    linear: function (t) {
        return t;
    },
    'ease-in': function (t) {
        return Math.pow(t, 1.675);
    },
    'ease-out': function (t) {
        return 1 - Math.pow(1 - t, 1.675);
    },
    'ease-in-out': function (t) {
        return 0.5 * (Math.sin((t - 0.5) * Math.PI) + 1);
    },
};
var Animation = /** @class */ (function () {
    function Animation() {
        this.active = false;
    }
    Animation.prototype.start = function (animation) {
        var _a;
        this.onStart = animation.onStart;
        this.onProgress = animation.onProgress;
        this.onStop = animation.onStop;
        if (!this.active) {
            (_a = this.onStart) === null || _a === void 0 ? void 0 : _a.call(this);
        }
        if (this.id) {
            window.cancelAnimationFrame(this.id);
        }
        this.startTime = performance.now();
        this.timingFunction = animation.timingFunction;
        this.endTime = this.startTime + animation.duration;
        this.active = true;
        this.animate();
    };
    Animation.prototype.animate = function () {
        var _this = this;
        if (this.startTime && this.endTime) {
            var timingFunction = timingFunctions[this.timingFunction];
            if (!timingFunction) {
                if (process.env.NODE_ENV !== 'production') {
                    console.warn("[Animation] The timing function '" + timingFunction + "' is not supported. Available timing function: 'linear', 'ease-in', 'ease-in-out', 'ease-out'. Reset to 'ease-out'.");
                }
                timingFunction = timingFunctions['ease-out'];
            }
            var percent = 1 - (this.endTime - performance.now()) / (this.endTime - this.startTime);
            var progress = Math.min(1, timingFunction(percent));
            if (this.onProgress) {
                this.onProgress(progress);
            }
            if (percent < 1) {
                this.id = window.requestAnimationFrame(function () { return _this.animate(); });
            }
            else {
                this.stop();
            }
        }
        else {
            this.stop();
        }
    };
    Animation.prototype.stop = function () {
        this.active = false;
        if (this.id) {
            window.cancelAnimationFrame(this.id);
        }
        if (this.onStop) {
            this.onStop();
        }
    };
    return Animation;
}());

function prepareSource(canvas, image, _a) {
    var rotate = _a.rotate, flip = _a.flip;
    var originalSize = {
        width: 'naturalWidth' in image ? image.naturalWidth : image.width,
        height: 'naturalHeight' in image ? image.naturalHeight : image.height,
    };
    var transformedSize = rotateSize(originalSize, rotate);
    var ctx = canvas.getContext('2d');
    canvas.height = transformedSize.height;
    canvas.width = transformedSize.width;
    if (ctx) {
        ctx.save();
        // Rotation:
        var canvasCenter = rotatePoint(getCenter(tslib.__assign({ left: 0, top: 0 }, originalSize)), rotate);
        ctx.translate(-(canvasCenter.left - transformedSize.width / 2), -(canvasCenter.top - transformedSize.height / 2));
        ctx.rotate((rotate * Math.PI) / 180);
        // Reflection;
        ctx.translate(flip.horizontal ? originalSize.width : 0, flip.vertical ? originalSize.height : 0);
        ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);
        ctx.drawImage(image, 0, 0, originalSize.width, originalSize.height);
        ctx.restore();
    }
    return canvas;
}
function updateCanvas(canvas, source, coordinates, resultSize, options) {
    canvas.width = resultSize ? resultSize.width : coordinates.width;
    canvas.height = resultSize ? resultSize.height : coordinates.height;
    var ctx = canvas.getContext('2d');
    if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (options) {
            if (options.imageSmoothingEnabled) {
                ctx.imageSmoothingEnabled = options.imageSmoothingEnabled;
            }
            if (options.imageSmoothingQuality) {
                ctx.imageSmoothingQuality = options.imageSmoothingQuality;
            }
            if (options.fillColor) {
                ctx.fillStyle = options.fillColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
            }
        }
        ctx.drawImage(source, coordinates.left, coordinates.top, coordinates.width, coordinates.height, 0, 0, canvas.width, canvas.height);
    }
    return canvas;
}
function drawCroppedArea(state, image, resultCanvas, spareCanvas, options) {
    if (isInitializedState(state)) {
        var transforms = state.transforms, coordinates = state.coordinates;
        var imageTransformed = transforms.rotate !== 0 || transforms.flip.horizontal || transforms.flip.vertical;
        var source = imageTransformed ? prepareSource(spareCanvas, image, transforms) : image;
        var params = tslib.__assign({ minWidth: 0, minHeight: 0, maxWidth: Infinity, maxHeight: Infinity, maxArea: Infinity, imageSmoothingEnabled: true, imageSmoothingQuality: 'high', fillColor: 'transparent' }, options);
        var firstNumeric = function (array) { return array.find(function (el) { return isNumeric(el); }); };
        var size = approximateSize({
            sizeRestrictions: {
                minWidth: firstNumeric([params.width, params.minWidth]) || 0,
                minHeight: firstNumeric([params.height, params.minHeight]) || 0,
                maxWidth: firstNumeric([params.width, params.maxWidth]) || Infinity,
                maxHeight: firstNumeric([params.height, params.maxHeight]) || Infinity,
            },
            width: coordinates.width,
            height: coordinates.height,
            aspectRatio: {
                minimum: coordinates.width / coordinates.height,
                maximum: coordinates.width / coordinates.height,
            },
        });
        if (params.maxArea && size.width * size.height > params.maxArea) {
            var scale = Math.sqrt(params.maxArea / (size.width * size.height));
            size = {
                width: Math.round(scale * size.width),
                height: Math.round(scale * size.height),
            };
        }
        return updateCanvas(resultCanvas, source, coordinates, size, params);
    }
    else {
        return null;
    }
}

function stretchCropperBoundary(boundary, stretcher, size) {
    // Reset stretcher
    stretcher.style.width = "0px";
    stretcher.style.height = "0px";
    // Try to fit the size by width:
    stretcher.style.width = Math.max(boundary.clientWidth, size.width) + "px";
    // After that try to fit the size by height and resulted width:
    var ratio = size.width / size.height;
    stretcher.style.height = Math.max(boundary.clientHeight, stretcher.clientWidth / ratio) + "px";
    stretcher.style.width = stretcher.clientHeight * ratio + "px";
}
function stretchPreviewBoundary(boundary, stretcher, size) {
    // Reset stretcher
    stretcher.style.width = "0px";
    stretcher.style.height = "0px";
    // Stretch the boundary with respect to its width
    var width = Math.max(boundary.clientWidth, size.width);
    stretcher.style.width = width + "px";
    stretcher.style.height = width / ratio(size) + "px";
    // If the height of boundary larger than current stretcher height
    // stretch the boundary with respect to its height
    if (stretcher.clientHeight < boundary.clientHeight) {
        stretcher.style.height = boundary.clientHeight + "px";
        stretcher.style.width = stretcher.clientHeight * ratio(size) + "px";
    }
}

var XHR_DONE = 4;
function base64ToArrayBuffer(base64) {
    base64 = base64.replace(/^data:([^;]+);base64,/gim, '');
    var binary = atob(base64);
    var len = binary.length;
    var buffer = new ArrayBuffer(len);
    var view = new Uint8Array(buffer);
    for (var i = 0; i < len; i++) {
        view[i] = binary.charCodeAt(i);
    }
    return buffer;
}
function objectURLToBlob(url, callback) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';
    http.onload = function () {
        if (this.status == 200 || this.status === 0) {
            callback(this.response);
        }
    };
    http.send();
}
function getTransforms(orientation) {
    var result = {
        flip: {
            horizontal: false,
            vertical: false,
        },
        rotate: 0,
    };
    if (orientation) {
        switch (orientation) {
            case 2:
                result.flip.horizontal = true;
                break;
            case 3:
                result.rotate = -180;
                break;
            case 4:
                result.flip.vertical = true;
                break;
            case 5:
                result.rotate = 90;
                result.flip.vertical = true;
                break;
            case 6:
                result.rotate = 90;
                break;
            case 7:
                result.rotate = 90;
                result.flip.horizontal = true;
                break;
            case 8:
                result.rotate = -90;
                break;
        }
    }
    return result;
}
function getImageData(img) {
    return new Promise(function (resolve, reject) {
        try {
            if (img) {
                if (/^data:/i.test(img)) {
                    // Data URL
                    resolve(base64ToArrayBuffer(img));
                }
                else if (/^blob:/i.test(img)) {
                    // Blob
                    var fileReader_1 = new FileReader();
                    fileReader_1.onload = function (e) {
                        var _a;
                        resolve((_a = e.target) === null || _a === void 0 ? void 0 : _a.result);
                    };
                    objectURLToBlob(img, function (blob) {
                        fileReader_1.readAsArrayBuffer(blob);
                    });
                }
                else {
                    // Simple URL
                    var http_1 = new XMLHttpRequest();
                    http_1.onreadystatechange = function () {
                        if (http_1.readyState !== XHR_DONE)
                            return;
                        if (http_1.status === 200 || http_1.status === 0) {
                            resolve(http_1.response);
                        }
                        else {
                            reject('Warning: could not load an image to parse its orientation');
                        }
                    };
                    http_1.onprogress = function () {
                        // Abort the request directly if it not a JPEG image for better performance
                        if (http_1.getResponseHeader('content-type') !== 'image/jpeg') {
                            http_1.abort();
                        }
                    };
                    http_1.withCredentials = false;
                    http_1.open('GET', img, true);
                    http_1.responseType = 'arraybuffer';
                    http_1.send(null);
                }
            }
            else {
                reject('Error: the image is empty');
            }
        }
        catch (e) {
            reject(e);
        }
    });
}
function getStyleTransforms(_a) {
    var rotate = _a.rotate, flip = _a.flip, scale = _a.scale;
    var transform = '';
    transform += " rotate(" + rotate + "deg) ";
    transform += " scaleX(" + scale * (flip.horizontal ? -1 : 1) + ") ";
    transform += " scaleY(" + scale * (flip.vertical ? -1 : 1) + ") ";
    return transform;
}
function getStringFromCharCode(dataView, start, length) {
    var str = '';
    var i;
    for (i = start, length += start; i < length; i++) {
        str += String.fromCharCode(dataView.getUint8(i));
    }
    return str;
}
function resetAndGetOrientation(arrayBuffer) {
    try {
        var dataView = new DataView(arrayBuffer);
        var orientation_1;
        var exifIDCode = void 0;
        var tiffOffset = void 0;
        var littleEndian = void 0;
        var app1Start = void 0;
        var ifdStart = void 0;
        // Only handle JPEG image (start by 0xFFD8)
        if (dataView.getUint8(0) === 0xff && dataView.getUint8(1) === 0xd8) {
            var length_1 = dataView.byteLength;
            var offset = 2;
            while (offset + 1 < length_1) {
                if (dataView.getUint8(offset) === 0xff && dataView.getUint8(offset + 1) === 0xe1) {
                    app1Start = offset;
                    break;
                }
                offset++;
            }
        }
        if (app1Start) {
            exifIDCode = app1Start + 4;
            tiffOffset = app1Start + 10;
            if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
                var endianness = dataView.getUint16(tiffOffset);
                littleEndian = endianness === 0x4949;
                if (littleEndian || endianness === 0x4d4d /* bigEndian */) {
                    if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002a) {
                        var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
                        if (firstIFDOffset >= 0x00000008) {
                            ifdStart = tiffOffset + firstIFDOffset;
                        }
                    }
                }
            }
        }
        if (ifdStart) {
            var length_2 = dataView.getUint16(ifdStart, littleEndian);
            for (var i = 0; i < length_2; i++) {
                var offset = ifdStart + i * 12 + 2;
                if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {
                    // 8 is the offset of the current tag's value
                    offset += 8;
                    // Get the original orientation value
                    orientation_1 = dataView.getUint16(offset, littleEndian);
                    // Override the orientation with its default value
                    dataView.setUint16(offset, 1, littleEndian);
                    break;
                }
            }
        }
        return orientation_1;
    }
    catch (error) {
        return null;
    }
}
function arrayBufferToDataURL(arrayBuffer) {
    var chunks = [];
    // Chunk Typed Array for better performance
    var chunkSize = 8192;
    var uint8 = new Uint8Array(arrayBuffer);
    while (uint8.length > 0) {
        var value = uint8.subarray(0, chunkSize);
        chunks.push(String.fromCharCode.apply(null, (Array.from ? Array.from(value) : value.slice())));
        uint8 = uint8.subarray(chunkSize);
    }
    return "data:image/jpeg;base64," + btoa(chunks.join(''));
}
function getImage(_a) {
    var src = _a.src, _b = _a.arrayBuffer, arrayBuffer = _b === void 0 ? null : _b, _c = _a.orientation, orientation = _c === void 0 ? null : _c;
    var options = {
        src: src,
        arrayBuffer: arrayBuffer,
        revoke: false,
        transforms: {
            flip: {
                horizontal: false,
                vertical: false,
            },
            rotate: 0,
        },
    };
    if (arrayBuffer && orientation && orientation > 1) {
        if (isBlob(src) || !isLocal(src)) {
            options.src = URL.createObjectURL(new Blob([arrayBuffer]));
            options.revoke = true;
        }
        else {
            options.src = arrayBufferToDataURL(arrayBuffer);
        }
    }
    else {
        options.src = src;
    }
    if (orientation) {
        options.transforms = getTransforms(orientation);
    }
    return options;
}
function parseImage(src, settings) {
    if (settings === void 0) { settings = {}; }
    var checkOrientation = settings.checkOrientation, parse = settings.parse;
    return new Promise(function (resolve) {
        if (checkOrientation || parse) {
            getImageData(src)
                .then(function (data) {
                var orientation = resetAndGetOrientation(data);
                resolve(getImage(data
                    ? { src: src, arrayBuffer: data, orientation: orientation }
                    : { src: src, arrayBuffer: null, orientation: null }));
            })
                .catch(function (error) {
                console.warn(error);
                resolve(getImage({ src: src }));
            });
        }
        else {
            resolve(getImage({ src: src }));
        }
    });
}
function createImage(src, settings) {
    if (settings === void 0) { settings = {}; }
    return new Promise(function (resolve, reject) {
        var image = document.createElement('img');
        if (settings.crossOrigin) {
            image.crossOrigin = settings.crossOrigin !== true ? settings.crossOrigin : 'anonymous';
        }
        image.src = src;
        image.style.visibility = 'hidden';
        image.style.position = 'fixed';
        document.body.appendChild(image);
        if (image.complete) {
            resolve(image);
            document.body.removeChild(image);
        }
        else {
            image.addEventListener('load', function () {
                resolve(image);
                document.body.removeChild(image);
            });
            image.addEventListener('error', function () {
                reject(null);
                document.body.removeChild(image);
            });
        }
    });
}
function loadImage(src, settings) {
    if (settings === void 0) { settings = {}; }
    return parseImage(src, tslib.__assign(tslib.__assign({}, settings), { crossOrigin: isCrossOriginURL(src) && settings.crossOrigin })).then(function (options) {
        return new Promise(function (resolve, reject) {
            createImage(options.src, settings)
                .then(function (image) {
                resolve(tslib.__assign(tslib.__assign({}, options), { width: image.naturalWidth, height: image.naturalHeight }));
            })
                .catch(function () {
                reject(null);
            });
        });
    });
}
function getImageStyle(image, state, area, coefficient, transitions) {
    if (transitions === void 0) { transitions = null; }
    var optimalImageSize = image.width > image.height
        ? {
            width: Math.min(512, image.width),
            height: Math.min(512, image.width) / (image.width / image.height),
        }
        : {
            height: Math.min(512, image.height),
            width: Math.min(512, image.height) * (image.width / image.height),
        };
    var actualImageSize = getTransformedImageSize(state);
    var imageTransforms = {
        rotate: state.transforms.rotate,
        flip: {
            horizontal: state.transforms.flip.horizontal,
            vertical: state.transforms.flip.vertical,
        },
        translateX: area.left / coefficient,
        translateY: area.top / coefficient,
        scale: 1 / coefficient,
    };
    var compensations = {
        rotate: {
            left: (optimalImageSize.width - actualImageSize.width) / (2 * coefficient),
            top: (optimalImageSize.height - actualImageSize.height) / (2 * coefficient),
        },
        scale: {
            left: ((1 - 1 / coefficient) * optimalImageSize.width) / 2,
            top: ((1 - 1 / coefficient) * optimalImageSize.height) / 2,
        },
    };
    var transforms = tslib.__assign(tslib.__assign({}, imageTransforms), { scale: imageTransforms.scale * (image.width / optimalImageSize.width) });
    var result = {
        width: optimalImageSize.width + "px",
        height: optimalImageSize.height + "px",
        left: '0px',
        top: '0px',
        transition: 'none',
        transform: "translate3d(" + (-compensations.rotate.left - compensations.scale.left - imageTransforms.translateX) + "px, " + (-compensations.rotate.top - compensations.scale.top - imageTransforms.translateY) + "px, 0px)" + getStyleTransforms(transforms),
        willChange: 'none',
    };
    if (transitions && transitions.active) {
        result.willChange = 'transform';
        result.transition = transitions.duration + "ms " + transitions.timingFunction;
    }
    return result;
}
function getBackgroundStyle(image, state, transitions) {
    if (transitions === void 0) { transitions = null; }
    if (image && state && state.visibleArea) {
        return getImageStyle(image, state, state.visibleArea, getCoefficient(state), transitions);
    }
    else {
        return {};
    }
}
function getPreviewStyle(image, state, coefficient, transitions) {
    if (transitions === void 0) { transitions = null; }
    if (image && state && state.visibleArea && state.coordinates) {
        return getImageStyle(image, state, state.coordinates, coefficient, transitions);
    }
    else {
        return {};
    }
}

function omitEmpty(obj) {
    var properties = {};
    Object.keys(obj).forEach(function (key) {
        if (!isUndefined(obj[key])) {
            properties[key] = obj[key];
        }
    });
    return properties;
}
function splitAbstractCropperProps(props) {
    var src = props.src, autoReconcileState = props.autoReconcileState, backgroundWrapperComponent = props.backgroundWrapperComponent, backgroundWrapperProps = props.backgroundWrapperProps, wrapperComponent = props.wrapperComponent, wrapperProps = props.wrapperProps, stencilComponent = props.stencilComponent, stencilConstraints = props.stencilConstraints, stencilProps = props.stencilProps, className = props.className, imageClassName = props.imageClassName, boundaryClassName = props.boundaryClassName, backgroundClassName = props.backgroundClassName, backgroundComponent = props.backgroundComponent, backgroundProps = props.backgroundProps, checkOrientation = props.checkOrientation, canvas = props.canvas, crossOrigin = props.crossOrigin, boundarySizeAlgorithm = props.boundarySizeAlgorithm, boundaryStretchAlgorithm = props.boundaryStretchAlgorithm, style = props.style, onReady = props.onReady, onError = props.onError, unloadTime = props.unloadTime, getInstance = props.getInstance, onTransitionsStart = props.onTransitionsStart, onTransitionsEnd = props.onTransitionsEnd, onChange = props.onChange, onResizeEnd = props.onResizeEnd, onMoveEnd = props.onMoveEnd, onMove = props.onMove, onResize = props.onResize, onTransformImage = props.onTransformImage, onTransformImageEnd = props.onTransformImageEnd, onInteractionStart = props.onInteractionStart, onInteractionEnd = props.onInteractionEnd, transitions = props.transitions, postProcess = props.postProcess, setCoordinatesAlgorithm = props.setCoordinatesAlgorithm, setVisibleAreaAlgorithm = props.setVisibleAreaAlgorithm, setBoundaryAlgorithm = props.setBoundaryAlgorithm, transformImageAlgorithm = props.transformImageAlgorithm, moveCoordinatesAlgorithm = props.moveCoordinatesAlgorithm, resizeCoordinatesAlgorithm = props.resizeCoordinatesAlgorithm, createStateAlgorithm = props.createStateAlgorithm, reconcileStateAlgorithm = props.reconcileStateAlgorithm, defaultTransforms = props.defaultTransforms, priority = props.priority, settings = tslib.__rest(props, ["src", "autoReconcileState", "backgroundWrapperComponent", "backgroundWrapperProps", "wrapperComponent", "wrapperProps", "stencilComponent", "stencilConstraints", "stencilProps", "className", "imageClassName", "boundaryClassName", "backgroundClassName", "backgroundComponent", "backgroundProps", "checkOrientation", "canvas", "crossOrigin", "boundarySizeAlgorithm", "boundaryStretchAlgorithm", "style", "onReady", "onError", "unloadTime", "getInstance", "onTransitionsStart", "onTransitionsEnd", "onChange", "onResizeEnd", "onMoveEnd", "onMove", "onResize", "onTransformImage", "onTransformImageEnd", "onInteractionStart", "onInteractionEnd", "transitions", "postProcess", "setCoordinatesAlgorithm", "setVisibleAreaAlgorithm", "setBoundaryAlgorithm", "transformImageAlgorithm", "moveCoordinatesAlgorithm", "resizeCoordinatesAlgorithm", "createStateAlgorithm", "reconcileStateAlgorithm", "defaultTransforms", "priority"]);
    return tslib.__assign(tslib.__assign({}, omitEmpty({
        src: src,
        autoReconcileState: autoReconcileState,
        backgroundWrapperComponent: backgroundWrapperComponent,
        backgroundWrapperProps: backgroundWrapperProps,
        wrapperComponent: wrapperComponent,
        wrapperProps: wrapperProps,
        stencilComponent: stencilComponent,
        stencilConstraints: stencilConstraints,
        stencilProps: stencilProps,
        className: className,
        imageClassName: imageClassName,
        boundaryClassName: boundaryClassName,
        backgroundClassName: backgroundClassName,
        backgroundComponent: backgroundComponent,
        backgroundProps: backgroundProps,
        checkOrientation: checkOrientation,
        canvas: canvas,
        crossOrigin: crossOrigin,
        boundarySizeAlgorithm: boundarySizeAlgorithm,
        boundaryStretchAlgorithm: boundaryStretchAlgorithm,
        style: style,
        onReady: onReady,
        onError: onError,
        unloadTime: unloadTime,
        getInstance: getInstance,
        onTransitionsStart: onTransitionsStart,
        onTransitionsEnd: onTransitionsEnd,
        onChange: onChange,
        onResizeEnd: onResizeEnd,
        onMoveEnd: onMoveEnd,
        onMove: onMove,
        onResize: onResize,
        onTransformImage: onTransformImage,
        onTransformImageEnd: onTransformImageEnd,
        onInteractionStart: onInteractionStart,
        onInteractionEnd: onInteractionEnd,
        transitions: transitions,
        postProcess: postProcess,
        setCoordinatesAlgorithm: setCoordinatesAlgorithm,
        setVisibleAreaAlgorithm: setVisibleAreaAlgorithm,
        setBoundaryAlgorithm: setBoundaryAlgorithm,
        transformImageAlgorithm: transformImageAlgorithm,
        moveCoordinatesAlgorithm: moveCoordinatesAlgorithm,
        resizeCoordinatesAlgorithm: resizeCoordinatesAlgorithm,
        createStateAlgorithm: createStateAlgorithm,
        reconcileStateAlgorithm: reconcileStateAlgorithm,
        defaultTransforms: defaultTransforms,
        priority: priority,
    })), { settings: settings });
}
function createCropper(render) {
    return React.forwardRef(render);
}

function hybridStencilAutoZoomAlgorithm(state, settings) {
    if (isInitializedState(state)) {
        var result = copyState(state);
        // Checks that coordinates has the same ratio that coordinates:
        var stencil = {
            width: 0,
            height: 0,
        };
        if (ratio(result.boundary) > ratio(result.coordinates)) {
            stencil.height = result.boundary.height * 0.8;
            stencil.width = stencil.height * ratio(result.coordinates);
        }
        else {
            stencil.width = result.boundary.width * 0.8;
            stencil.height = stencil.width * ratio(result.coordinates);
        }
        // First of all try to resize visible area as much as possible:
        result.visibleArea = applyScale(result.visibleArea, (result.coordinates.width * result.boundary.width) / (result.visibleArea.width * stencil.width));
        // Check that visible area doesn't break the area restrictions:
        var scale = fitToSizeRestrictions(result.visibleArea, getAreaSizeRestrictions(result, settings));
        result.visibleArea = applyScale(result.visibleArea, scale);
        if (scale !== 1) {
            stencil.height /= scale;
            stencil.width /= scale;
        }
        result.visibleArea = applyMove(result.visibleArea, diff(getCenter(result.coordinates), getCenter(result.visibleArea)));
        // Center stencil in visible area:
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        result.coordinates = moveToPositionRestrictions(result.coordinates, mergePositionRestrictions(coordinatesToPositionRestrictions(result.visibleArea), getPositionRestrictions(result, settings)));
        return result;
    }
    return state;
}
function hybridStencilAutoZoom(state, settings, action) {
    if (action.immediately) {
        return hybridStencilAutoZoomAlgorithm(state, settings);
    }
    return state;
}

function deprecationWarning(text) {
    if (process.env.NODE_ENV === 'development') {
        console.warn("Deprecation warning: ".concat(text));
    }
}

function useDeprecationWarning() {
    var fired = React.useRef([]);
    return function (message) {
        if (fired.current.indexOf(message) === -1) {
            deprecationWarning(message);
            fired.current.push(message);
        }
    };
}

var useWindowResize = function (callback) {
    var callbackRef = React.useRef(callback);
    var internalCallback = function () {
        if (callbackRef.current) {
            callbackRef.current();
        }
    };
    React.useEffect(function () {
        callbackRef.current = callback;
    }, [callback]);
    React.useEffect(function () {
        window.addEventListener('resize', internalCallback);
        window.addEventListener('orientationchange', internalCallback);
        return function () {
            window.removeEventListener('resize', internalCallback);
            window.removeEventListener('orientationchange', internalCallback);
        };
    }, []);
};

function useCropperImage(options) {
    var src = options.src, onLoadingStart = options.onLoadingStart, onLoadingEnd = options.onLoadingEnd, onError = options.onError, onLoad = options.onLoad, crossOrigin = options.crossOrigin, checkOrientation = options.checkOrientation, canvas = options.canvas;
    var _a = tslib.__read(React.useState(false), 2), loading = _a[0], setLoading = _a[1];
    var _b = tslib.__read(React.useState(false), 2), loaded = _b[0], setLoaded = _b[1];
    var _c = tslib.__read(React.useState(null), 2), image = _c[0], setImage = _c[1];
    var currentSrc = React.useRef(null);
    React.useEffect(function () {
        if (currentSrc.current !== src) {
            currentSrc.current = src || null;
            setLoaded(false);
            if (src) {
                setLoading(true);
                onLoadingStart === null || onLoadingStart === void 0 ? void 0 : onLoadingStart();
                var promises = [
                    loadImage(src, {
                        crossOrigin: isUndefined(crossOrigin) ? canvas : crossOrigin,
                        checkOrientation: checkOrientation,
                    }),
                ];
                if (loaded && options.unloadTime) {
                    promises.push(promiseTimeout(options.unloadTime));
                }
                Promise.all(promises)
                    .then(function (responses) {
                    var _a = tslib.__read(responses, 1), image = _a[0];
                    if (currentSrc.current === src) {
                        setImage(image);
                        onLoad === null || onLoad === void 0 ? void 0 : onLoad(image);
                    }
                })
                    .catch(function () {
                    if (currentSrc.current === src) {
                        onError === null || onError === void 0 ? void 0 : onError();
                    }
                })
                    .finally(function () {
                    if (currentSrc.current === src) {
                        onLoadingEnd === null || onLoadingEnd === void 0 ? void 0 : onLoadingEnd();
                        setLoading(false);
                    }
                });
            }
            else {
                if (options.unloadTime) {
                    promiseTimeout(options.unloadTime).then(function () {
                        setImage(null);
                    });
                }
                else {
                    setImage(null);
                }
            }
        }
    }, [src]);
    React.useEffect(function () {
        if (image) {
            setLoaded(true);
        }
    }, [image]);
    return { loading: loading, loaded: loaded, image: image, setImage: setImage };
}

function useForceRerender() {
    var _a = tslib.__read(React.useState({}), 2); _a[0]; var setTick = _a[1];
    return function () {
        setTick({});
    };
}

function useCropperProps(props) {
    var propsRef = React.useRef(props);
    propsRef.current = props;
    return function () { return propsRef.current(); };
}

function useCropperState(props, settings) {
    var rerender = useForceRerender();
    var getProps = useCropperProps(function () {
        var _a = props(), settings = _a.settings, parameters = tslib.__rest(_a, ["settings"]);
        var extendedSettings = tslib.__assign({ imageRestriction: exports.ImageRestriction.fitArea, transformImage: {
                adjustStencil: true,
            } }, settings);
        var extendedParameters = tslib.__assign({ transitions: true }, parameters);
        return tslib.__assign({ settings: tslib.__assign(tslib.__assign({}, extendedSettings), createDefaultSettings(extendedSettings)) }, extendedParameters);
    });
    var cropper = React.useRef(new CropperInstance({
        getProps: getProps,
        setData: function () {
            rerender();
        },
    }));
    React.useLayoutEffect(function () {
        if (settings.autoReconcileState && !cropper.current.hasInteractions()) {
            cropper.current.reconcileState();
        }
    });
    return cropper.current;
}

function mergeRefs(refs) {
    return function (value) {
        refs.forEach(function (ref) {
            if (typeof ref === 'function') {
                ref(value);
            }
            else if (ref != null) {
                ref.current = value;
            }
        });
    };
}

function useFirstMountState() {
    var isFirst = React.useRef(true);
    if (isFirst.current) {
        isFirst.current = false;
        return true;
    }
    return isFirst.current;
}

var useUpdateEffect = function (effect, deps) {
    var isFirstMount = useFirstMountState();
    React.useEffect(function () {
        if (!isFirstMount) {
            return effect();
        }
    }, deps);
};

function useStateWithCallback(initialState) {
    var _a = tslib.__read(React.useState(initialState), 2), state = _a[0], setState = _a[1];
    var _b = tslib.__read(React.useState(null), 2), callback = _b[0], setCallback = _b[1];
    var previousState = React.useRef(initialState);
    useUpdateEffect(function () {
        if (callback) {
            callback(state, previousState.current);
        }
    }, [callback]);
    return [
        state,
        function (value, callback) {
            previousState.current = state;
            setState(value);
            setCallback(function () { return callback; });
        }
    ];
}

var StretchableBoundary = React.forwardRef(function (_a, ref) {
    var className = _a.className, style = _a.style, stretcherClassName = _a.stretcherClassName, contentClassName = _a.contentClassName, _b = _a.stretchAlgorithm, stretchAlgorithm = _b === void 0 ? stretchCropperBoundary : _b, _c = _a.sizeAlgorithm, sizeAlgorithm = _c === void 0 ? fillBoundary : _c, children = _a.children;
    var stretcherRef = React.useRef(null);
    var boundaryRef = React.useRef(null);
    React.useImperativeHandle(ref, function () { return ({
        reset: function () {
            var stretcher = stretcherRef.current;
            if (stretcher) {
                stretcher.style.height = '';
                stretcher.style.width = '';
            }
        },
        stretchTo: function (size) {
            var stretcher = stretcherRef.current;
            var boundary = boundaryRef.current;
            if ((size === null || size === void 0 ? void 0 : size.width) && (size === null || size === void 0 ? void 0 : size.height) && stretcher && boundary) {
                stretchAlgorithm(boundary, stretcher, size);
                var result = sizeAlgorithm(boundary, size);
                return Promise.resolve(result.width && result.height ? result : null);
            }
            else {
                if (stretcher) {
                    stretcher.style.height = '';
                    stretcher.style.width = '';
                }
                return Promise.resolve(null);
            }
        },
    }); });
    return (React__default["default"].createElement("div", { ref: boundaryRef, style: style, className: cn__default["default"]('advanced-cropper-boundary', className) },
        React__default["default"].createElement("div", { ref: stretcherRef, className: cn__default["default"](['advanced-cropper-boundary__stretcher', stretcherClassName]) }),
        React__default["default"].createElement("div", { className: cn__default["default"](['advanced-cropper-boundary__content', contentClassName]) }, children)));
});
StretchableBoundary.displayName = 'StretchableBoundary';

var CropperFade = function (_a) {
    var visible = _a.visible, className = _a.className, style = _a.style, children = _a.children;
    return (React__default["default"].createElement("div", { style: style, className: cn__default["default"](className, 'advanced-cropper-fade', Boolean(visible) && 'advanced-cropper-fade--visible') }, children));
};

var CropperWrapper = function (_a) {
    var cropper = _a.cropper, children = _a.children, loaded = _a.loaded, className = _a.className, style = _a.style;
    var state = cropper ? cropper.getState() : null;
    return (React__default["default"].createElement("div", { className: cn__default["default"](className, 'advanced-cropper-wrapper'), style: style },
        React__default["default"].createElement(CropperFade, { visible: state && loaded, className: 'advanced-cropper-wrapper__fade' }, children)));
};

function preventDefault(e) {
    e.preventDefault();
}

var CropperBackgroundImage = React.forwardRef(function (_a, ref) {
    var className = _a.className, cropper = _a.cropper, crossOrigin = _a.crossOrigin;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var image = cropper.getImage();
    var style = image && state ? getBackgroundStyle(image, state, transitions) : {};
    var src = image ? image.src : undefined;
    return src ? (React__default["default"].createElement("img", { key: src, ref: ref, className: cn__default["default"]('advanced-cropper-background-image', className), src: src, crossOrigin: crossOrigin === true ? 'anonymous' : crossOrigin || undefined, style: style, onMouseDown: preventDefault })) : null;
});
CropperBackgroundImage.displayName = 'CropperBackgroundImage';

var CropperCanvas = React.forwardRef(function (_, ref) {
    var canvasRef = React.useRef(null);
    var spareCanvasRef = React.useRef(null);
    React.useImperativeHandle(ref, function () { return ({
        draw: function (state, image, options) {
            if (options === void 0) { options = {}; }
            if (image && canvasRef.current && spareCanvasRef.current) {
                return drawCroppedArea(state, image, canvasRef.current, spareCanvasRef.current, options);
            }
            else {
                return null;
            }
        },
    }); });
    return (React__default["default"].createElement(React__default["default"].Fragment, null,
        React__default["default"].createElement("canvas", { className: "advanced-cropper-canvas", ref: canvasRef }),
        React__default["default"].createElement("canvas", { className: "advanced-cropper-canvas", ref: spareCanvasRef })));
});
CropperCanvas.displayName = 'CropperCanvas';

var DraggableElement = /** @class */ (function (_super) {
    tslib.__extends(DraggableElement, _super);
    function DraggableElement(props) {
        var _this = _super.call(this, props) || this;
        _this.processMove = function (e, newTouches) {
            var _a;
            var container = _this.container.current;
            if (container && _this.touches.length) {
                var _b = container.getBoundingClientRect(), left = _b.left, top_1 = _b.top;
                if (_this.touches.length === 1 && newTouches.length === 1) {
                    if (_this.props.onMove) {
                        var movingToAnchor = {
                            left: Math.abs(newTouches[0].clientX - _this.anchor.left - left) <
                                Math.abs(_this.touches[0].clientX - _this.anchor.left - left),
                            top: Math.abs(newTouches[0].clientY - _this.anchor.top - top_1) <
                                Math.abs(_this.touches[0].clientY - _this.anchor.top - top_1),
                        };
                        var direction = {
                            left: 0,
                            top: 0,
                        };
                        if (!_this.props.useAnchor || !movingToAnchor.left) {
                            direction.left = newTouches[0].clientX - _this.touches[0].clientX;
                        }
                        if (!_this.props.useAnchor || !movingToAnchor.top) {
                            direction.top = newTouches[0].clientY - _this.touches[0].clientY;
                        }
                        (_a = _this.props) === null || _a === void 0 ? void 0 : _a.onMove(direction, e);
                        _this.touches = tslib.__spreadArray([], tslib.__read(newTouches), false);
                    }
                }
            }
        };
        _this.processEnd = function () {
            var _a = _this.props, onMoveEnd = _a.onMoveEnd, onLeave = _a.onLeave;
            if (!_this.props.disabled && _this.touches.length) {
                onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd();
            }
            if (_this.hovered) {
                onLeave === null || onLeave === void 0 ? void 0 : onLeave();
                _this.hovered = false;
            }
            _this.touches = [];
        };
        _this.initAnchor = function (touch) {
            var container = _this.container.current;
            if (container) {
                var _a = container.getBoundingClientRect(), left = _a.left, top_2 = _a.top;
                _this.anchor = {
                    left: touch.clientX - left,
                    top: touch.clientY - top_2,
                };
            }
        };
        _this.onMouseOver = function () {
            var _a = _this.props, onEnter = _a.onEnter, disabled = _a.disabled;
            if (!_this.hovered && !disabled) {
                _this.hovered = true;
                onEnter === null || onEnter === void 0 ? void 0 : onEnter();
            }
        };
        _this.onMouseLeave = function () {
            var onLeave = _this.props.onLeave;
            if (_this.hovered && !_this.touches.length) {
                _this.hovered = false;
                onLeave === null || onLeave === void 0 ? void 0 : onLeave();
            }
        };
        _this.onTouchStart = function (e) {
            var _a = _this.props, onEnter = _a.onEnter, onMoveStart = _a.onMoveStart, disabled = _a.disabled;
            if (e.cancelable) {
                _this.touches = Array.from(e.touches);
                var shouldStartMove = !disabled && e.touches.length === 1;
                if (shouldStartMove) {
                    _this.touches = Array.from(e.touches);
                    onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart();
                }
                if (!_this.hovered && !disabled) {
                    _this.hovered = true;
                    onEnter === null || onEnter === void 0 ? void 0 : onEnter();
                }
                if (_this.started || shouldStartMove) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
        };
        _this.onTouchEnd = function () {
            _this.started = false;
            _this.processEnd();
        };
        _this.onTouchMove = function (e) {
            if (_this.touches.length >= 1) {
                if (_this.started) {
                    _this.processMove(e, Array.from(e.touches));
                    e.preventDefault();
                    e.stopPropagation();
                }
                else if (distance({ left: _this.touches[0].clientX, top: _this.touches[0].clientY }, { left: e.touches[0].clientX, top: e.touches[0].clientY }) > (_this.props.activationDistance || 0)) {
                    _this.initAnchor({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY,
                    });
                    _this.started = true;
                }
            }
        };
        _this.onMouseDown = function (e) {
            var _a = _this.props, onMoveStart = _a.onMoveStart, disabled = _a.disabled;
            if (!disabled && e.button === 0) {
                var touch = {
                    clientX: e.clientX,
                    clientY: e.clientY,
                };
                _this.touches = [touch];
                _this.initAnchor(touch);
                e.stopPropagation();
                onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart();
            }
        };
        _this.onMouseMove = function (e) {
            if (!_this.props.disabled && _this.touches.length) {
                _this.processMove(e, [
                    {
                        clientX: e.clientX,
                        clientY: e.clientY,
                    },
                ]);
                if (e.preventDefault && e.cancelable) {
                    e.preventDefault();
                }
                e.stopPropagation();
            }
        };
        _this.onMouseUp = function () {
            _this.processEnd();
        };
        _this.touches = [];
        _this.hovered = false;
        _this.started = false;
        _this.anchor = {
            left: 0,
            top: 0,
        };
        _this.container = React.createRef();
        return _this;
    }
    DraggableElement.prototype.shouldComponentUpdate = function () {
        return !!this.props.rerender;
    };
    DraggableElement.prototype.componentWillUnmount = function () {
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        var container = this.container.current;
        if (container) {
            container.removeEventListener('touchstart', this.onTouchStart);
            container.removeEventListener('mousedown', this.onMouseDown);
        }
    };
    DraggableElement.prototype.componentDidMount = function () {
        window.addEventListener('mouseup', this.onMouseUp, { passive: false });
        window.addEventListener('mousemove', this.onMouseMove, { passive: false });
        window.addEventListener('touchmove', this.onTouchMove, { passive: false });
        window.addEventListener('touchend', this.onTouchEnd, { passive: false });
        var container = this.container.current;
        if (container) {
            // Add event listeners here due to https://github.com/facebook/react/issues/9809#issuecomment-414072263
            container.addEventListener('touchstart', this.onTouchStart, {
                passive: false,
            });
            container.addEventListener('mousedown', this.onMouseDown, {
                passive: false,
            });
        }
    };
    DraggableElement.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.disabled && !prevProps.disabled) {
            this.touches = [];
        }
    };
    DraggableElement.prototype.render = function () {
        var _a = this.props, children = _a.children, className = _a.className;
        return (React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-draggable-element', className), ref: this.container, onMouseOver: this.onMouseOver, onMouseLeave: this.onMouseLeave }, children));
    };
    DraggableElement.defaultProps = {
        disabled: false,
        activationDistance: 30,
        useAnchor: true,
        rerender: true,
    };
    return DraggableElement;
}(React.Component));

var LineWrapper = function (_a) {
    var position = _a.position, className = _a.className, disabled = _a.disabled, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onLeave = _a.onLeave, onEnter = _a.onEnter, children = _a.children;
    return (React__default["default"].createElement(DraggableElement, { className: cn__default["default"]([
            'advanced-cropper-line-wrapper',
            position && "advanced-cropper-line-wrapper--".concat(position),
            className,
        ]), disabled: disabled, onMove: onDrag, onMoveEnd: onDragEnd, onLeave: onLeave, onEnter: onEnter, activationDistance: 0 },
        React__default["default"].createElement("div", { className: cn__default["default"]([
                'advanced-cropper-line-wrapper__content',
                position && "advanced-cropper-line-wrapper__content--".concat(position),
            ]) }, children)));
};

var SimpleLine = function (_a) {
    var _b, _c;
    var position = _a.position, hoverClassName = _a.hoverClassName, wrapperClassName = _a.wrapperClassName, defaultClassName = _a.defaultClassName, disabled = _a.disabled, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd;
    var _d = tslib.__read(React.useState(false), 2), hover = _d[0], setHover = _d[1];
    var onEnter = function () {
        setHover(true);
    };
    var onLeave = function () {
        setHover(false);
    };
    return (React__default["default"].createElement(LineWrapper, { className: cn__default["default"]('advanced-cropper-simple-line-wrapper', wrapperClassName, (_b = {},
            _b["advanced-cropper-simple-line-wrapper--".concat(position)] = !!position,
            _b)), position: position, disabled: disabled, onDrag: onDrag, onDragEnd: onDragEnd, onLeave: onLeave, onEnter: onEnter },
        React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-simple-line', hover && 'advanced-cropper-simple-line--hover', defaultClassName, hover && hoverClassName, (_c = {},
                _c["advanced-cropper-simple-line--".concat(position)] = !!position,
                _c)) })));
};

var HandlerWrapper = function (_a) {
    var horizontalPosition = _a.horizontalPosition, verticalPosition = _a.verticalPosition, className = _a.className, disabled = _a.disabled, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onLeave = _a.onLeave, onEnter = _a.onEnter, children = _a.children, style = _a.style;
    var position = horizontalPosition || verticalPosition
        ? getDirectionNames(horizontalPosition, verticalPosition).snakeCase
        : null;
    return (React__default["default"].createElement("div", { style: style, className: cn__default["default"](className, 'advanced-cropper-handler-wrapper', position && "advanced-cropper-handler-wrapper--".concat(position), disabled && 'advanced-cropper-handler-wrapper--disabled') },
        React__default["default"].createElement(DraggableElement, { className: 'advanced-cropper-handler-wrapper__draggable', disabled: disabled, onMove: onDrag, onMoveEnd: onDragEnd, onLeave: onLeave, onEnter: onEnter, activationDistance: 0 }, children)));
};

var SimpleHandler = function (_a) {
    var _b;
    var verticalPosition = _a.verticalPosition, horizontalPosition = _a.horizontalPosition, hoverClassName = _a.hoverClassName, wrapperClassName = _a.wrapperClassName, defaultClassName = _a.defaultClassName, wrapperStyle = _a.wrapperStyle, disabled = _a.disabled, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd;
    var _c = tslib.__read(React.useState(false), 2), hover = _c[0], setHover = _c[1];
    var onEnter = function () {
        setHover(true);
    };
    var onLeave = function () {
        setHover(false);
    };
    return (React__default["default"].createElement(HandlerWrapper, { style: wrapperStyle, className: cn__default["default"]('advanced-cropper-simple-handler-wrapper', wrapperClassName, verticalPosition && "advanced-cropper-simple-handler-wrapper--".concat(verticalPosition), horizontalPosition && "advanced-cropper-simple-handler-wrapper--".concat(horizontalPosition), horizontalPosition &&
            verticalPosition &&
            "advanced-cropper-simple-handler-wrapper--".concat(horizontalPosition, "-").concat(verticalPosition), hover && 'advanced-cropper-simple-handler-wrapper--hover'), verticalPosition: verticalPosition, horizontalPosition: horizontalPosition, disabled: disabled, onDrag: onDrag, onDragEnd: onDragEnd, onLeave: onLeave, onEnter: onEnter },
        React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-simple-handler', hover && 'advanced-cropper-simple-handler--hover', defaultClassName, hover && hoverClassName, (_b = {},
                _b["advanced-cropper-simple-handler--".concat(verticalPosition)] = !!verticalPosition,
                _b["advanced-cropper-simple-handler--".concat(horizontalPosition)] = !!horizontalPosition,
                _b["advanced-cropper-simple-handler--".concat(horizontalPosition, "-").concat(verticalPosition)] = horizontalPosition && verticalPosition,
                _b)) })));
};

var HORIZONTAL_DIRECTIONS = ['east', 'west', null];
var VERTICAL_DIRECTIONS = ['south', 'north', null];
var BoundingBox = function (_a) {
    var style = _a.style, className = _a.className, children = _a.children, onResize = _a.onResize, onResizeEnd = _a.onResizeEnd, _b = _a.handlerComponent, handlerComponent = _b === void 0 ? SimpleHandler : _b, _c = _a.handlers, handlers = _c === void 0 ? {
        eastNorth: true,
        north: true,
        westNorth: true,
        west: true,
        westSouth: true,
        south: true,
        eastSouth: true,
        east: true,
    } : _c, _d = _a.handlerClassNames, handlerClassNames = _d === void 0 ? {} : _d, _e = _a.handlerWrapperClassNames, handlerWrapperClassNames = _e === void 0 ? {} : _e, _f = _a.lines, lines = _f === void 0 ? {
        west: true,
        north: true,
        east: true,
        south: true,
    } : _f, _g = _a.lineComponent, lineComponent = _g === void 0 ? SimpleLine : _g, _h = _a.lineClassNames, lineClassNames = _h === void 0 ? {} : _h, _j = _a.lineWrapperClassNames, lineWrapperClassNames = _j === void 0 ? {} : _j, _k = _a.disabled, disabled = _k === void 0 ? false : _k;
    var points = React.useMemo(function () {
        var result = [];
        HORIZONTAL_DIRECTIONS.forEach(function (hDirection) {
            VERTICAL_DIRECTIONS.forEach(function (vDirection) {
                if (hDirection !== vDirection) {
                    var _a = getDirectionNames(hDirection, vDirection), snakeCase = _a.snakeCase, camelCase = _a.camelCase;
                    if (snakeCase && camelCase) {
                        result.push({
                            name: camelCase,
                            className: snakeCase,
                            verticalPosition: vDirection,
                            horizontalPosition: hDirection,
                        });
                    }
                }
            });
        });
        return result;
    }, []);
    var lineNodes = React.useMemo(function () {
        var result = [];
        points.forEach(function (point) {
            if (isCardinalDirection(point.name) && (isObject(lines) ? lines[point.name] : lines)) {
                result.push({
                    name: point.name,
                    component: lineComponent,
                    className: cn__default["default"](lineClassNames.default, lineClassNames[point.name], disabled && lineClassNames.disabled),
                    wrapperClassName: cn__default["default"]("advanced-cropper-bounding-box__line", "advanced-cropper-bounding-box__line--".concat(point.name), lineWrapperClassNames.default, lineWrapperClassNames[point.name], disabled && lineWrapperClassNames.disabled),
                    hoverClassName: lineClassNames.hover,
                    verticalPosition: point.verticalPosition,
                    horizontalPosition: point.horizontalPosition,
                    disabled: disabled,
                });
            }
        });
        return result;
    }, [points, lines, lineComponent, lineClassNames, lineWrapperClassNames, disabled]);
    var handlerNodes = React.useMemo(function () {
        var result = [];
        points.forEach(function (point) {
            if (isObject(handlers) ? handlers[point.name] : handlers) {
                result.push({
                    name: point.name,
                    component: handlerComponent,
                    className: cn__default["default"](handlerClassNames.default, handlerClassNames[point.name]),
                    containerClassName: cn__default["default"]("advanced-cropper-bounding-box__handler-wrapper", "advanced-cropper-bounding-box__handler-wrapper--".concat(point.className)),
                    wrapperClassName: cn__default["default"]("advanced-cropper-bounding-box__handler", "advanced-cropper-bounding-box__handler--".concat(point.className), handlerWrapperClassNames.default, handlerWrapperClassNames[point.name]),
                    hoverClassName: handlerClassNames.hover,
                    verticalPosition: point.verticalPosition,
                    horizontalPosition: point.horizontalPosition,
                    disabled: disabled,
                });
            }
        });
        return result;
    }, [points, handlers, handlerComponent, handlerClassNames, handlerWrapperClassNames, disabled]);
    var onHandlerDrag = function (horizontalDirection, verticalDirection) {
        return function (_a, nativeEvent) {
            var left = _a.left, top = _a.top;
            var directions = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            };
            if (horizontalDirection === 'west') {
                directions.left -= left;
            }
            else if (horizontalDirection === 'east') {
                directions.right += left;
            }
            if (verticalDirection === 'north') {
                directions.top -= top;
            }
            else if (verticalDirection === 'south') {
                directions.bottom += top;
            }
            var respectDirection;
            if (!verticalDirection && horizontalDirection) {
                respectDirection = 'width';
            }
            else if (verticalDirection && !horizontalDirection) {
                respectDirection = 'height';
            }
            if (!disabled) {
                if (onResize) {
                    onResize(directions, {
                        allowedDirections: {
                            left: horizontalDirection === 'west' || !horizontalDirection,
                            right: horizontalDirection === 'east' || !horizontalDirection,
                            bottom: verticalDirection === 'south' || !verticalDirection,
                            top: verticalDirection === 'north' || !verticalDirection,
                        },
                        preserveAspectRatio: nativeEvent && nativeEvent.shiftKey,
                        respectDirection: respectDirection,
                    });
                }
            }
        };
    };
    return (React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-bounding-box', className), style: style },
        children,
        React__default["default"].createElement("div", null, lineNodes.map(function (line) { return (React__default["default"].createElement(line.component, { key: line.name, defaultClassName: line.className, hoverClassName: line.hoverClassName, wrapperClassName: line.wrapperClassName, position: line.name, disabled: line.disabled, onDrag: onHandlerDrag(line.horizontalPosition, line.verticalPosition), onDragEnd: onResizeEnd })); })),
        React__default["default"].createElement("div", null, handlerNodes.map(function (handler) {
            var handlerElement = (React__default["default"].createElement(handler.component, { defaultClassName: handler.className, hoverClassName: handler.hoverClassName, wrapperClassName: handler.wrapperClassName, horizontalPosition: handler.horizontalPosition, verticalPosition: handler.verticalPosition, disabled: handler.disabled, onDrag: onHandlerDrag(handler.horizontalPosition, handler.verticalPosition), onDragEnd: onResizeEnd }));
            return (React__default["default"].createElement("div", { key: handler.name, className: handler.containerClassName }, handlerElement));
        }))));
};

var StencilOverlay = function (_a) {
    var className = _a.className, children = _a.children;
    return React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-stencil-overlay', className) }, children);
};

function useTransition(transitions) {
    if (transitions === void 0) { transitions = null; }
    var animation = React.useRef(new Animation());
    var _a = tslib.__read(React.useState(false), 2), active = _a[0], setActive = _a[1];
    return [
        function (callback) {
            if (transitions && transitions.active) {
                animation.current.start(tslib.__assign(tslib.__assign({}, transitions), { onStart: function () {
                        setActive(true);
                    }, onProgress: function (progress) {
                        callback(progress);
                    }, onStop: function () {
                        setActive(false);
                    } }));
            }
            else if (!animation.current.active) {
                callback(1);
            }
        },
        active,
    ];
}

var ArtificialTransition = function (_a) {
    var className = _a.className, transitions = _a.transitions, children = _a.children, values = tslib.__rest(_a, ["className", "transitions", "children"]);
    var root = React.useRef(null);
    var transitionValues = React.useRef(values);
    var _b = tslib.__read(React.useState(values), 2), rememberedValues = _b[0], setRememberedValues = _b[1];
    var _c = tslib.__read(useTransition(transitions), 2), runTransitions = _c[0], transitionsActive = _c[1];
    React.useLayoutEffect(function () {
        if (!deepCompare(rememberedValues, values)) {
            setRememberedValues(values);
            var startValues_1 = transitionsActive
                ? tslib.__assign({}, transitionValues.current) : rememberedValues;
            runTransitions(function (progress) {
                var properties = ['left', 'top', 'height', 'width'];
                properties.forEach(function (property) {
                    var desiredValue = values[property];
                    var startValue = startValues_1[property];
                    transitionValues.current[property] =
                        isNumber(startValue) && isNumber(desiredValue)
                            ? startValue + (desiredValue - startValue) * progress
                            : desiredValue;
                });
                if (root.current) {
                    root.current.style.width = "".concat(transitionValues.current.width, "px");
                    root.current.style.height = "".concat(transitionValues.current.height, "px");
                    root.current.style.transform = "translate3d(".concat(transitionValues.current.left, "px, ").concat(transitionValues.current.top, "px, 0px)");
                }
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [rememberedValues, transitionsActive, values.width, values.height, values.top, values.left]);
    var currentValues = transitionsActive ? transitionValues.current : values;
    var rootStyle = {
        left: 0,
        top: 0,
        width: "".concat(currentValues.width, "px"),
        height: "".concat(currentValues.height, "px"),
        transform: "translate3d(".concat(currentValues.left, "px, ").concat(currentValues.top, "px, 0px)"),
    };
    return (React__default["default"].createElement("div", { ref: root, className: cn__default["default"]('advanced-cropper-artificial-transition', className), style: rootStyle }, children));
};

var StencilWrapper = function (_a) {
    var className = _a.className, transitions = _a.transitions, width = _a.width, height = _a.height, left = _a.left, top = _a.top, children = _a.children;
    return (React__default["default"].createElement(ArtificialTransition, { className: cn__default["default"]('advanced-cropper-stencil-wrapper', className), transitions: transitions, width: width, height: height, top: top, left: left }, children));
};

var StencilGrid = function (_a) {
    var _b = _a.columns, columns = _b === void 0 ? 3 : _b, _c = _a.rows, rows = _c === void 0 ? 3 : _c, _d = _a.visible, visible = _d === void 0 ? false : _d, className = _a.className;
    var nodes = [];
    var _e = tslib.__read(React.useState(columns), 2), currentColumns = _e[0], setCurrentColumns = _e[1];
    var _f = tslib.__read(React.useState(rows), 2), currentRows = _f[0], setCurrentRows = _f[1];
    useUpdateEffect(function () {
        if (visible) {
            setCurrentRows(rows);
            setCurrentColumns(columns);
        }
    }, [visible, columns, rows]);
    for (var i = 0; i < currentRows; i++) {
        var cells = [];
        for (var j = 0; j < currentColumns; j++) {
            cells.push(React__default["default"].createElement("div", { key: j, className: cn__default["default"]('advanced-cropper-stencil-grid__cell', i === 0 && 'advanced-cropper-stencil-grid__cell--top', i === currentRows - 1 && 'advanced-cropper-stencil-grid__cell--bottom', j === 0 && 'advanced-cropper-stencil-grid__cell--left', j === currentColumns - 1 && 'advanced-cropper-stencil-grid__cell--right') }));
        }
        nodes.push(React__default["default"].createElement("div", { key: i, className: 'advanced-cropper-stencil-grid__row' }, cells));
    }
    return (React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-stencil-grid', visible && 'advanced-cropper-stencil-grid--visible', className) }, nodes));
};

var RectangleStencil = React.forwardRef(function (_a, ref) {
    var cropper = _a.cropper, aspectRatio = _a.aspectRatio, minAspectRatio = _a.minAspectRatio, maxAspectRatio = _a.maxAspectRatio, _b = _a.handlerComponent, handlerComponent = _b === void 0 ? SimpleHandler : _b, _c = _a.handlers, handlers = _c === void 0 ? {
        eastNorth: true,
        north: true,
        westNorth: true,
        west: true,
        westSouth: true,
        south: true,
        eastSouth: true,
        east: true,
    } : _c, _d = _a.handlerClassNames, handlerClassNames = _d === void 0 ? {} : _d, _e = _a.handlerWrapperClassNames, handlerWrapperClassNames = _e === void 0 ? {} : _e, _f = _a.lines, lines = _f === void 0 ? {
        west: true,
        north: true,
        east: true,
        south: true,
    } : _f, _g = _a.lineComponent, lineComponent = _g === void 0 ? SimpleLine : _g, _h = _a.lineClassNames, lineClassNames = _h === void 0 ? {} : _h, _j = _a.lineWrapperClassNames, lineWrapperClassNames = _j === void 0 ? {} : _j, _k = _a.resizable, resizable = _k === void 0 ? true : _k, _l = _a.movable, movable = _l === void 0 ? true : _l, grid = _a.grid, gridClassName = _a.gridClassName, movingClassName = _a.movingClassName, resizingClassName = _a.resizingClassName, previewClassName = _a.previewClassName, boundingBoxClassName = _a.boundingBoxClassName, overlayClassName = _a.overlayClassName, draggableAreaClassName = _a.draggableAreaClassName;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var interactions = cropper.getInteractions();
    React.useImperativeHandle(ref, function () { return ({
        aspectRatio: createAspectRatio(aspectRatio || {
            minimum: minAspectRatio,
            maximum: maxAspectRatio,
        }),
    }); });
    var onMove = function (directions) {
        if (cropper && movable) {
            cropper.moveCoordinates(directions);
        }
    };
    var onMoveEnd = function () {
        if (cropper) {
            cropper.moveCoordinatesEnd();
        }
    };
    var onResize = function (directions, options) {
        if (cropper && resizable) {
            cropper.resizeCoordinates(directions, options);
        }
    };
    var onResizeEnd = function () {
        if (cropper) {
            cropper.resizeCoordinatesEnd();
        }
    };
    var _m = getStencilCoordinates(state), width = _m.width, height = _m.height, left = _m.left, top = _m.top;
    return (state && (React__default["default"].createElement(StencilWrapper, { className: cn__default["default"]('advanced-cropper-rectangle-stencil', movable && 'advanced-cropper-rectangle-stencil--movable', interactions.moveCoordinates && 'advanced-cropper-rectangle-stencil--moving', resizable && 'advanced-cropper-rectangle-stencil--resizable', interactions.resizeCoordinates && 'advanced-cropper-rectangle-stencil--resizing', interactions.moveCoordinates && movingClassName, interactions.resizeCoordinates && resizingClassName), width: width, height: height, left: left, top: top, transitions: transitions },
        React__default["default"].createElement(BoundingBox, { className: cn__default["default"](boundingBoxClassName, 'advanced-cropper-rectangle-stencil__bounding-box'), handlers: handlers, handlerComponent: handlerComponent, handlerClassNames: handlerClassNames, handlerWrapperClassNames: handlerWrapperClassNames, lines: lines, lineComponent: lineComponent, lineClassNames: lineClassNames, lineWrapperClassNames: lineWrapperClassNames, onResize: onResize, onResizeEnd: onResizeEnd, disabled: !resizable },
            React__default["default"].createElement(DraggableElement, { disabled: !movable, onMove: onMove, onMoveEnd: onMoveEnd, className: cn__default["default"]('advanced-cropper-rectangle-stencil__draggable-area', draggableAreaClassName) },
                React__default["default"].createElement(StencilOverlay, { className: cn__default["default"]('advanced-cropper-rectangle-stencil__overlay', overlayClassName) },
                    grid && (React__default["default"].createElement(StencilGrid, { visible: cropper.hasInteractions(), columns: interactions.transformImage.rotate ? 9 : 3, rows: interactions.transformImage.rotate ? 9 : 3, className: cn__default["default"]('advanced-cropper-rectangle-stencil__grid', gridClassName) })),
                    React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-rectangle-stencil__preview', previewClassName) })))))));
});
RectangleStencil.displayName = 'RectangleStencil';

function useRotateImageOptions(rotateImage) {
    return React.useMemo(function () {
        return getOptions(rotateImage, {
            touch: true,
        }, {
            touch: false,
        });
    }, [rotateImage]);
}

function useScaleImageOptions(scaleImage) {
    return React.useMemo(function () {
        return getOptions(scaleImage, {
            touch: true,
            wheel: {
                ratio: 0.1,
            },
        }, {
            touch: false,
            wheel: false,
        });
    }, [scaleImage]);
}

function useMoveImageOptions(moveImage) {
    return React.useMemo(function () {
        return getOptions(moveImage, {
            touch: true,
            mouse: true,
        }, {
            touch: false,
            mouse: false,
        });
    }, [moveImage]);
}

var TransformableImageEvent = /** @class */ (function () {
    function TransformableImageEvent(_a) {
        var active = _a.active;
        this.active = active;
        this.defaultPrevented = false;
    }
    TransformableImageEvent.prototype.preventDefault = function () {
        this.defaultPrevented = true;
    };
    return TransformableImageEvent;
}());
var TransformableImage = /** @class */ (function (_super) {
    tslib.__extends(TransformableImage, _super);
    function TransformableImage(props) {
        var _this = _super.call(this, props) || this;
        _this.processMove = function (newTouches) {
            var _a = _this.props, onTransform = _a.onTransform, touchScale = _a.touchScale, touchMove = _a.touchMove, touchRotate = _a.touchRotate;
            var container = _this.container.current;
            if (container && onTransform) {
                onTransform(touchesToImageTransform(newTouches, _this.touches, container, {
                    scale: touchScale,
                    rotate: touchRotate,
                    move: touchMove,
                }));
                _this.touches = newTouches;
            }
        };
        _this.processEnd = function () {
            var onTransformEnd = _this.props.onTransformEnd;
            if (_this.transforming) {
                _this.transforming = false;
                if (onTransformEnd) {
                    onTransformEnd();
                }
            }
        };
        _this.processStart = function () {
            _this.transforming = true;
            _this.debouncedProcessEnd.clear();
        };
        _this.processEvent = function (nativeEvent) {
            var _a = _this.props, onEvent = _a.onEvent, disabled = _a.disabled;
            var transformEvent = new TransformableImageEvent({ active: _this.transforming });
            if (onEvent) {
                onEvent(transformEvent, nativeEvent);
            }
            else {
                nativeEvent.preventDefault();
                nativeEvent.stopPropagation();
            }
            return !disabled && !transformEvent.defaultPrevented;
        };
        _this.onWheel = function (event) {
            var _a = _this.props, onTransform = _a.onTransform, wheelScale = _a.wheelScale;
            var container = _this.container.current;
            if (wheelScale) {
                if (_this.processEvent(event)) {
                    _this.processStart();
                    if (onTransform && container) {
                        onTransform(wheelEventToImageTransform(event, container, wheelScale === true ? 0.1 : wheelScale.ratio));
                    }
                    if (!_this.touches.length) {
                        _this.debouncedProcessEnd();
                    }
                }
            }
        };
        _this.onTouchStart = function (event) {
            var _a = _this.props, touchMove = _a.touchMove, touchScale = _a.touchScale, touchRotate = _a.touchRotate;
            if (event.cancelable && (touchMove || ((touchScale || touchRotate) && event.touches.length > 1))) {
                if (_this.processEvent(event)) {
                    var container = _this.container.current;
                    if (container) {
                        var _b = container.getBoundingClientRect(), left_1 = _b.left, top_1 = _b.top, bottom_1 = _b.bottom, right_1 = _b.right;
                        _this.touches = Array.from(event.touches).filter(function (touch) {
                            return touch.clientX > left_1 &&
                                touch.clientX < right_1 &&
                                touch.clientY > top_1 &&
                                touch.clientY < bottom_1;
                        });
                    }
                }
            }
        };
        _this.onTouchEnd = function (event) {
            if (event.touches.length === 0) {
                _this.touches = [];
                _this.processEnd();
            }
        };
        _this.onTouchMove = function (event) {
            if (_this.touches.length) {
                var touches = tslib.__spreadArray([], tslib.__read(event.touches), false).filter(function (touch) {
                    return !touch.identifier ||
                        _this.touches.find(function (anotherTouch) { return anotherTouch.identifier === touch.identifier; });
                });
                if (_this.processEvent(event)) {
                    _this.processMove(touches);
                    _this.processStart();
                }
            }
        };
        _this.onMouseDown = function (event) {
            var mouseMove = _this.props.mouseMove;
            if (mouseMove && 'buttons' in event && event.buttons === 1) {
                if (_this.processEvent(event)) {
                    var touch = {
                        clientX: event.clientX,
                        clientY: event.clientY,
                    };
                    _this.touches = [touch];
                    _this.processStart();
                }
            }
        };
        _this.onMouseMove = function (event) {
            if (_this.touches.length) {
                if (_this.processEvent(event)) {
                    _this.processMove([
                        {
                            clientX: event.clientX,
                            clientY: event.clientY,
                        },
                    ]);
                }
            }
        };
        _this.onMouseUp = function () {
            _this.touches = [];
            _this.processEnd();
        };
        _this.transforming = false;
        _this.touches = [];
        _this.anchor = {
            left: 0,
            top: 0,
        };
        _this.container = React.createRef();
        _this.debouncedProcessEnd = debounce(_this.processEnd, props.timeout);
        return _this;
    }
    TransformableImage.prototype.shouldComponentUpdate = function () {
        return true;
    };
    TransformableImage.prototype.componentWillUnmount = function () {
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        var container = this.container.current;
        if (container) {
            container.removeEventListener('touchstart', this.onTouchStart);
            container.removeEventListener('mousedown', this.onMouseDown);
            container.removeEventListener('wheel', this.onWheel);
        }
    };
    TransformableImage.prototype.componentDidMount = function () {
        window.addEventListener('mouseup', this.onMouseUp, { passive: false });
        window.addEventListener('mousemove', this.onMouseMove, { passive: false });
        window.addEventListener('touchmove', this.onTouchMove, { passive: false });
        window.addEventListener('touchend', this.onTouchEnd, { passive: false });
        var container = this.container.current;
        if (container) {
            // Add event listeners here due to https://github.com/facebook/react/issues/9809#issuecomment-414072263
            container.addEventListener('touchstart', this.onTouchStart, {
                passive: false,
            });
            container.addEventListener('mousedown', this.onMouseDown, {
                passive: false,
            });
            container.addEventListener('wheel', this.onWheel, {
                passive: false,
            });
        }
    };
    TransformableImage.prototype.render = function () {
        var _a = this.props, className = _a.className, children = _a.children, style = _a.style;
        return (React__default["default"].createElement("div", { className: className, style: style, ref: this.container }, children));
    };
    TransformableImage.defaultProps = {
        touchMove: true,
        mouseMove: true,
        touchScale: true,
        touchRotate: false,
        wheelScale: true,
        timeout: 500,
    };
    return TransformableImage;
}(React.Component));

var CropperBackgroundWrapper = function (_a) {
    var _b = _a.scaleImage, scaleImage = _b === void 0 ? true : _b, _c = _a.moveImage, moveImage = _c === void 0 ? true : _c, _d = _a.rotateImage, rotateImage = _d === void 0 ? false : _d, children = _a.children, className = _a.className, style = _a.style, cropper = _a.cropper, timeout = _a.timeout;
    var transitions = cropper.getTransitions();
    var rotateImageOptions = useRotateImageOptions(rotateImage);
    var scaleImageOptions = useScaleImageOptions(scaleImage);
    var moveImageOptions = useMoveImageOptions(moveImage);
    return (React__default["default"].createElement(TransformableImage, { className: className, style: style, onTransform: cropper.transformImage, onTransformEnd: cropper.transformImageEnd, touchMove: moveImageOptions.touch, mouseMove: moveImageOptions.mouse, touchScale: scaleImageOptions.touch, wheelScale: scaleImageOptions.wheel, touchRotate: rotateImageOptions.touch, disabled: transitions.active, timeout: timeout }, children));
};

var AbstractCropperComponent = function (props, ref) {
    var src = props.src, _a = props.stencilComponent, stencilComponent = _a === void 0 ? RectangleStencil : _a, _b = props.stencilConstraints, stencilConstraints = _b === void 0 ? defaultStencilConstraints : _b, _c = props.stencilProps, stencilProps = _c === void 0 ? {} : _c, _d = props.wrapperComponent, wrapperComponent = _d === void 0 ? CropperWrapper : _d, _e = props.wrapperProps, wrapperProps = _e === void 0 ? {} : _e, _f = props.backgroundComponent, backgroundComponent = _f === void 0 ? CropperBackgroundImage : _f, _g = props.backgroundProps, backgroundProps = _g === void 0 ? {} : _g, _h = props.backgroundWrapperComponent, backgroundWrapperComponent = _h === void 0 ? CropperBackgroundWrapper : _h, _j = props.backgroundWrapperProps, backgroundWrapperProps = _j === void 0 ? {} : _j, imageClassName = props.imageClassName, className = props.className, boundaryClassName = props.boundaryClassName, backgroundClassName = props.backgroundClassName, boundarySizeAlgorithm = props.boundarySizeAlgorithm, boundaryStretchAlgorithm = props.boundaryStretchAlgorithm, _k = props.crossOrigin, crossOrigin = _k === void 0 ? true : _k, _l = props.checkOrientation, checkOrientation = _l === void 0 ? true : _l, _m = props.autoReconcileState, autoReconcileState = _m === void 0 ? true : _m, _o = props.canvas, canvas = _o === void 0 ? true : _o, style = props.style, onReady = props.onReady, onError = props.onError, _p = props.unloadTime, unloadTime = _p === void 0 ? 500 : _p, settings = props.settings, parameters = tslib.__rest(props, ["src", "stencilComponent", "stencilConstraints", "stencilProps", "wrapperComponent", "wrapperProps", "backgroundComponent", "backgroundProps", "backgroundWrapperComponent", "backgroundWrapperProps", "imageClassName", "className", "boundaryClassName", "backgroundClassName", "boundarySizeAlgorithm", "boundaryStretchAlgorithm", "crossOrigin", "checkOrientation", "autoReconcileState", "canvas", "style", "onReady", "onError", "unloadTime", "settings"]);
    var stencilRef = React.useRef(null);
    var imageRef = React.useRef(null);
    var boundaryRef = React.useRef(null);
    var canvasRef = React.useRef(null);
    var cropperRef = React.useRef(null);
    var _q = tslib.__read(useStateWithCallback(null), 2), currentImage = _q[0], setCurrentImage = _q[1];
    var _r = tslib.__read(React.useState(false), 2), autoReconcileStateDisabled = _r[0], setAutoReconcileStateDisabled = _r[1];
    var cropper = useCropperState(function () { return (tslib.__assign(tslib.__assign({}, parameters), { getInstance: function () {
            return cropperRef.current;
        }, settings: tslib.__assign(tslib.__assign({}, settings), stencilConstraints(settings, tslib.__assign(tslib.__assign({}, stencilProps), stencilRef.current))) })); }, {
        autoReconcileState: autoReconcileState && !autoReconcileStateDisabled,
    });
    var _s = useCropperImage({
        src: src,
        crossOrigin: crossOrigin,
        checkOrientation: checkOrientation,
        unloadTime: unloadTime,
        canvas: canvas,
        onLoad: function () {
            if (cropperRef.current) {
                onReady === null || onReady === void 0 ? void 0 : onReady(cropperRef.current);
            }
        },
        onError: function () {
            if (cropperRef.current) {
                onError === null || onError === void 0 ? void 0 : onError(cropperRef.current);
            }
        },
    }), image = _s.image, loaded = _s.loaded, loading = _s.loading;
    var resetCropper = function () {
        var _a;
        if (boundaryRef.current) {
            setAutoReconcileStateDisabled(true);
            (_a = boundaryRef.current) === null || _a === void 0 ? void 0 : _a.stretchTo(image).then(function (boundary) {
                setCurrentImage(image, function () {
                    if (boundary && image) {
                        cropper.reset(boundary, image);
                    }
                    else {
                        cropper.clear();
                    }
                });
            }).finally(function () {
                setAutoReconcileStateDisabled(false);
            });
        }
    };
    var refreshCropper = function () {
        var _a;
        if (boundaryRef.current) {
            setAutoReconcileStateDisabled(true);
            (_a = boundaryRef.current) === null || _a === void 0 ? void 0 : _a.stretchTo(image).then(function (boundary) {
                if (boundary && image) {
                    var state = cropper.getState();
                    if (state) {
                        if (boundary.width !== state.boundary.width || boundary.height !== state.boundary.height) {
                            cropper.setBoundary(boundary);
                        }
                        // It's important because, probably, after the boundary reset
                        // the cropper can meet some restrictions that were broken before
                        cropper.reconcileState();
                    }
                    else {
                        cropper.reset(boundary, image);
                    }
                }
                else {
                    cropper.clear();
                }
            }).finally(function () {
                setAutoReconcileStateDisabled(false);
            });
        }
    };
    var cropperInterface = {
        reset: function () {
            resetCropper();
        },
        refresh: function () {
            refreshCropper();
        },
        getCanvas: function (options) {
            var state = cropper.getState();
            if (imageRef.current && canvasRef.current && state) {
                return canvasRef.current.draw(state, imageRef.current, options);
            }
            else {
                return null;
            }
        },
        getImage: function () {
            return currentImage ? tslib.__assign({}, currentImage) : null;
        },
        setImage: function (image) {
            setCurrentImage(image);
        },
        reconcileState: cropper.reconcileState,
        moveCoordinates: cropper.moveCoordinates,
        moveCoordinatesEnd: cropper.moveCoordinatesEnd,
        resizeCoordinates: cropper.resizeCoordinates,
        clear: cropper.clear,
        resizeCoordinatesEnd: cropper.resizeCoordinatesEnd,
        moveImage: cropper.moveImage,
        flipImage: cropper.flipImage,
        zoomImage: cropper.zoomImage,
        rotateImage: cropper.rotateImage,
        transformImage: cropper.transformImage,
        transformImageEnd: cropper.transformImageEnd,
        setCoordinates: cropper.setCoordinates,
        setState: cropper.setState,
        hasInteractions: cropper.hasInteractions,
        getStencilCoordinates: cropper.getStencilCoordinates,
        getCoordinates: cropper.getCoordinates,
        getVisibleArea: cropper.getVisibleArea,
        getTransforms: cropper.getTransforms,
        getTransitions: cropper.getTransitions,
        getInteractions: cropper.getInteractions,
        getSettings: cropper.getSettings,
        getState: cropper.getState,
        getDefaultState: function () {
            var state = cropper.getState();
            return state && image && cropper.createDefaultState(state.boundary, image);
        },
    };
    useWindowResize(function () {
        refreshCropper();
    });
    useUpdateEffect(function () {
        resetCropper();
    }, [image]);
    React.useImperativeHandle(mergeRefs([ref, cropperRef]), function () { return cropperInterface; });
    var StencilComponent = stencilComponent;
    var WrapperComponent = wrapperComponent;
    var BackgroundWrapperComponent = backgroundWrapperComponent;
    var BackgroundComponent = backgroundComponent;
    return (React__default["default"].createElement(WrapperComponent, tslib.__assign({}, wrapperProps, { className: cn__default["default"]('advanced-cropper', className), loaded: loaded, cropper: cropperInterface, loading: loading, style: style }),
        React__default["default"].createElement(StretchableBoundary, { ref: boundaryRef, stretchAlgorithm: boundaryStretchAlgorithm, sizeAlgorithm: boundarySizeAlgorithm, className: cn__default["default"]('advanced-cropper__boundary', boundaryClassName), stretcherClassName: cn__default["default"]('advanced-cropper__stretcher') },
            React__default["default"].createElement(BackgroundWrapperComponent, tslib.__assign({}, backgroundWrapperProps, { cropper: cropperInterface, className: 'advanced-cropper__background-wrapper' }),
                React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper__background', backgroundClassName) }, cropper.getState() && (React__default["default"].createElement(BackgroundComponent, tslib.__assign({}, backgroundProps, { ref: imageRef, crossOrigin: crossOrigin, cropper: cropperInterface, className: cn__default["default"]('advanced-cropper__image', imageClassName) })))),
                React__default["default"].createElement(StencilComponent, tslib.__assign({}, stencilProps, { ref: stencilRef, cropper: cropperInterface, image: currentImage }))),
            canvas && React__default["default"].createElement(CropperCanvas, { ref: canvasRef }))));
};
var AbstractCropper = createCropper(AbstractCropperComponent);

function fixedStencilConstraints(rawSettings, stencilOptions) {
    var defaultConstraints = defaultStencilConstraints({}, stencilOptions);
    return {
        stencilSize: function (state, settings) {
            var previousSize = isFunction(rawSettings.stencilSize)
                ? rawSettings.stencilSize(state, settings)
                : rawSettings.stencilSize;
            return approximateSize(tslib.__assign(tslib.__assign({}, previousSize), { aspectRatio: aspectRatioIntersection(defaultConstraints.aspectRatio, createAspectRatio(ratio(previousSize))) }));
        },
    };
}
function getStencilSize(state, settings) {
    var boundary = state.boundary;
    var size = isFunction(settings.stencilSize) ? settings.stencilSize(state, settings) : settings.stencilSize;
    if (size.width > boundary.width || size.height > boundary.height) {
        size = approximateSize({
            sizeRestrictions: {
                maxWidth: boundary.width,
                maxHeight: boundary.height,
                minWidth: 0,
                minHeight: 0,
            },
            width: size.width,
            height: size.height,
            aspectRatio: {
                minimum: ratio(size),
                maximum: ratio(size),
            },
        });
    }
    return size;
}
function sizeRestrictions(state, settings) {
    var stencilSize = getStencilSize(state, tslib.__assign(tslib.__assign({}, settings), { stencilSize: settings.stencilSize }));
    var areaRestrictions = getAreaSizeRestrictions(state, settings);
    return {
        maxWidth: (areaRestrictions.maxWidth * stencilSize.width) / state.boundary.width,
        maxHeight: (areaRestrictions.maxHeight * stencilSize.height) / state.boundary.height,
        minWidth: 0,
        minHeight: 0,
    };
}
function defaultSize(state, settings) {
    var imageSize = state.imageSize, visibleArea = state.visibleArea, boundary = state.boundary;
    var sizeRestrictions = getSizeRestrictions(state, settings);
    var aspectRatio = getAspectRatio(state, settings);
    var stencilSize = isFunction(settings.stencilSize) ? settings.stencilSize(state, settings) : settings.stencilSize;
    var area = (visibleArea || imageSize);
    var height, width;
    if (ratio(area) > ratio(boundary)) {
        height = (stencilSize.height * area.height) / boundary.height;
        width = height * ratio(stencilSize);
    }
    else {
        width = (stencilSize.width * area.width) / boundary.width;
        height = width / ratio(stencilSize);
    }
    return approximateSize({
        width: width,
        height: height,
        aspectRatio: aspectRatio,
        sizeRestrictions: sizeRestrictions,
    });
}
function aspectRatio(state, settings) {
    var value = ratio(getStencilSize(state, settings));
    return {
        minimum: value,
        maximum: value,
    };
}
function fixedStencilAlgorithm(state, settings) {
    if (isInitializedState(state)) {
        var result = copyState(state);
        var stencil = getStencilSize(state, settings);
        // First of all try to resize visible area as much as possible:
        result.visibleArea = applyScale(result.visibleArea, (result.coordinates.width * result.boundary.width) / (result.visibleArea.width * stencil.width));
        // Check that visible area doesn't break the area restrictions:
        var scale = fitToSizeRestrictions(result.visibleArea, getAreaSizeRestrictions(result, settings));
        if (scale !== 1) {
            result.visibleArea = applyScale(result.visibleArea, scale);
            result.coordinates = applyScale(result.coordinates, scale);
        }
        result.visibleArea = applyMove(result.visibleArea, diff(getCenter(result.coordinates), getCenter(result.visibleArea)));
        // Center stencil in visible area:
        result.visibleArea = moveToPositionRestrictions(result.visibleArea, getAreaPositionRestrictions(result, settings));
        result.coordinates = moveToPositionRestrictions(result.coordinates, mergePositionRestrictions(coordinatesToPositionRestrictions(result.visibleArea), getAreaPositionRestrictions(result, settings)));
        return result;
    }
    return state;
}
function fixedStencil(state, settings, action) {
    if (action && action.immediately) {
        return fixedStencilAlgorithm(state, settings);
    }
    return state;
}

var FixedCropperComponent = function (props, ref) {
    var _a = splitAbstractCropperProps(props), settings = _a.settings, parameters = tslib.__rest(_a, ["settings"]);
    return (React__default["default"].createElement(AbstractCropper, tslib.__assign({ postProcess: fixedStencil, stencilConstraints: fixedStencilConstraints }, parameters, { settings: tslib.__assign(tslib.__assign({ defaultSize: defaultSize, aspectRatio: aspectRatio, sizeRestrictions: withDefaultSizeRestrictions(sizeRestrictions) }, settings), { transformImage: tslib.__assign(tslib.__assign({}, settings.transformImage), { adjustStencil: false }) }), ref: ref })));
};
var FixedCropper = createCropper(FixedCropperComponent);

var CropperComponent = function (props, ref) {
    var _a = splitAbstractCropperProps(props), settings = _a.settings, postProcess = _a.postProcess, parameters = tslib.__rest(_a, ["settings", "postProcess"]);
    // Process the deprecated properties
    var _b = settings, stencilSize = _b.stencilSize, autoZoom = _b.autoZoom, actualSettings = tslib.__rest(_b, ["stencilSize", "autoZoom"]);
    var deprecationWarning = useDeprecationWarning();
    if (!isUndefined(autoZoom)) {
        if (postProcess || stencilSize) {
            deprecationWarning("prop 'autoZoom' is deprecated now and will be removed, use 'postProcess' prop to pass your auto zoom function.");
        }
        else {
            deprecationWarning("prop 'autoZoom' is deprecated now and will be removed, use 'postProcess' prop to pass your auto zoom function. The 'postProcess' automatically set to 'hybridAutoZoom'");
            postProcess = hybridStencilAutoZoom;
        }
    }
    if (!isUndefined(stencilSize)) {
        deprecationWarning("prop 'stencilSize' is deprecated for <Cropper/> component now and will be removed, use <FixedCropper/> component instead.");
        return (React__default["default"].createElement(FixedCropper, tslib.__assign({ ref: ref, stencilSize: stencilSize }, actualSettings, parameters)));
    }
    return (React__default["default"].createElement(AbstractCropper, tslib.__assign({}, parameters, { postProcess: postProcess, ref: ref, settings: actualSettings })));
};
var Cropper = createCropper(CropperComponent);

var CircleStencil = React.forwardRef(function (_a, ref) {
    var cropper = _a.cropper, _b = _a.handlerComponent, handlerComponent = _b === void 0 ? SimpleHandler : _b, _c = _a.handlers, handlers = _c === void 0 ? {
        eastNorth: true,
        westNorth: true,
        westSouth: true,
        eastSouth: true,
    } : _c, _d = _a.handlerClassNames, handlerClassNames = _d === void 0 ? {} : _d, _e = _a.handlerWrapperClassNames, handlerWrapperClassNames = _e === void 0 ? {} : _e, _f = _a.lines, lines = _f === void 0 ? {
        west: true,
        north: true,
        east: true,
        south: true,
    } : _f, _g = _a.lineComponent, lineComponent = _g === void 0 ? SimpleLine : _g, _h = _a.lineClassNames, lineClassNames = _h === void 0 ? {} : _h, _j = _a.lineWrapperClassNames, lineWrapperClassNames = _j === void 0 ? {} : _j, _k = _a.resizable, resizable = _k === void 0 ? true : _k, _l = _a.movable, movable = _l === void 0 ? true : _l, grid = _a.grid, gridClassName = _a.gridClassName, movingClassName = _a.movingClassName, resizingClassName = _a.resizingClassName, previewClassName = _a.previewClassName, boundingBoxClassName = _a.boundingBoxClassName, overlayClassName = _a.overlayClassName, draggableAreaClassName = _a.draggableAreaClassName;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var interactions = cropper.getInteractions();
    React.useImperativeHandle(ref, function () { return ({
        aspectRatio: 1,
        boundingBox: 'circle',
    }); });
    var onMove = function (directions) {
        if (cropper && movable) {
            cropper.moveCoordinates(directions);
        }
    };
    var onMoveEnd = function () {
        if (cropper) {
            cropper.moveCoordinatesEnd();
        }
    };
    var onResize = function (directions, options) {
        if (cropper && resizable) {
            cropper.resizeCoordinates(directions, options);
        }
    };
    var onResizeEnd = function () {
        if (cropper) {
            cropper.resizeCoordinatesEnd();
        }
    };
    var _m = getStencilCoordinates(state), width = _m.width, height = _m.height, left = _m.left, top = _m.top;
    return (state && (React__default["default"].createElement(StencilWrapper, { className: cn__default["default"]('advanced-cropper-circle-stencil', movable && 'advanced-cropper-circle-stencil--movable', interactions.moveCoordinates && 'advanced-cropper-circle-stencil--moving', resizable && 'advanced-cropper-circle-stencil--resizable', interactions.resizeCoordinates && 'advanced-cropper-circle-stencil--resizing', interactions.moveCoordinates && movingClassName, interactions.resizeCoordinates && resizingClassName), width: width, height: height, left: left, top: top, transitions: transitions },
        React__default["default"].createElement(BoundingBox, { className: cn__default["default"](boundingBoxClassName, 'advanced-cropper-circle-stencil__bounding-box'), handlers: handlers, handlerComponent: handlerComponent, handlerClassNames: handlerClassNames, handlerWrapperClassNames: handlerWrapperClassNames, lines: lines, lineComponent: lineComponent, lineClassNames: lineClassNames, lineWrapperClassNames: lineWrapperClassNames, onResize: onResize, onResizeEnd: onResizeEnd, disabled: !resizable },
            React__default["default"].createElement(DraggableElement, { disabled: !movable, onMove: onMove, onMoveEnd: onMoveEnd, className: cn__default["default"]('advanced-cropper-circle-stencil__draggable-area', draggableAreaClassName) },
                React__default["default"].createElement(StencilOverlay, { className: cn__default["default"]('advanced-cropper-circle-stencil__overlay', overlayClassName) },
                    grid && (React__default["default"].createElement(StencilGrid, { visible: cropper.hasInteractions(), columns: interactions.transformImage.rotate ? 9 : 3, rows: interactions.transformImage.rotate ? 9 : 3, className: cn__default["default"]('advanced-cropper-circle-stencil__grid', gridClassName) })),
                    React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-circle-stencil__preview', previewClassName) })))))));
});
CircleStencil.displayName = 'CircleStencil';

var CropperPreview = function (_a) {
    var className = _a.className, contentClassName = _a.contentClassName, imageClassName = _a.imageClassName, state = _a.state, image = _a.image, _b = _a.transitions, transitions = _b === void 0 ? null : _b;
    var boundaryRef = React.useRef(null);
    var _c = tslib.__read(React.useState(null), 2), size = _c[0], setSize = _c[1];
    var _d = tslib.__read(React.useState(1), 2), coefficient = _d[0], setCoefficient = _d[1];
    var imageStyle = state && state.coordinates && image && size ? getPreviewStyle(image, state, coefficient, transitions) : {};
    var contentStyle = size
        ? {
            width: "".concat(size.width, "px"),
            height: "".concat(size.height, "px"),
        }
        : {};
    var refresh = function () {
        if (boundaryRef.current && (state === null || state === void 0 ? void 0 : state.coordinates)) {
            boundaryRef.current.stretchTo(state.coordinates).then(function (size) {
                if (size && state.coordinates) {
                    if (!isLower(ratio(state.coordinates), ratio(size))) {
                        setSize({
                            width: size.width,
                            height: size.width / ratio(state.coordinates),
                        });
                        setCoefficient(state.coordinates.width / size.width);
                    }
                    else {
                        setSize({
                            width: size.height * ratio(state.coordinates),
                            height: size.height,
                        });
                        setCoefficient(state.coordinates.height / size.height);
                    }
                }
                else {
                    setSize(null);
                }
            });
        }
    };
    useWindowResize(refresh);
    React.useLayoutEffect(function () {
        if (state === null || state === void 0 ? void 0 : state.coordinates) {
            refresh();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [image === null || image === void 0 ? void 0 : image.src, state === null || state === void 0 ? void 0 : state.coordinates]);
    return (React__default["default"].createElement(StretchableBoundary, { ref: boundaryRef, stretchAlgorithm: stretchPreviewBoundary, className: cn__default["default"](className, 'advanced-cropper-preview') },
        React__default["default"].createElement("div", { className: cn__default["default"](contentClassName, 'advanced-cropper-preview__content'), style: contentStyle },
            React__default["default"].createElement("img", { src: image ? image.src : undefined, className: cn__default["default"](imageClassName, 'advanced-cropper-preview__image', image && image.src && 'advanced-cropper-preview__image--visible'), style: imageStyle }))));
};

exports.AbstractCropper = AbstractCropper$1;
exports.Animation = Animation;
exports.BoundingBox = BoundingBox;
exports.CircleStencil = CircleStencil;
exports.Cropper = Cropper;
exports.CropperBackgroundImage = CropperBackgroundImage;
exports.CropperBackgroundWrapper = CropperBackgroundWrapper;
exports.CropperCanvas = CropperCanvas;
exports.CropperFade = CropperFade;
exports.CropperInstance = CropperInstance;
exports.CropperPreview = CropperPreview;
exports.CropperWrapper = CropperWrapper;
exports.DraggableArea = DraggableElement;
exports.DraggableElement = DraggableElement;
exports.FixedCropper = FixedCropper;
exports.RectangleStencil = RectangleStencil;
exports.SimpleHandler = SimpleHandler;
exports.SimpleLine = SimpleLine;
exports.StencilOverlay = StencilOverlay;
exports.StencilWrapper = StencilWrapper;
exports.StretchableBoundary = StretchableBoundary;
exports.TransformableImage = TransformableImage;
exports.TransformableImageEvent = TransformableImageEvent;
exports.applyDirections = applyDirections;
exports.applyMove = applyMove;
exports.applyScale = applyScale;
exports.approximateSize = approximateSize;
exports.aspectRatioIntersection = aspectRatioIntersection;
exports.calculateAreaSizeRestrictions = calculateAreaSizeRestrictions;
exports.calculateSizeRestrictions = calculateSizeRestrictions;
exports.coordinatesToPositionRestrictions = coordinatesToPositionRestrictions;
exports.copyState = copyState;
exports.createAspectRatio = createAspectRatio;
exports.createDefaultSettings = createDefaultSettings;
exports.createImage = createImage;
exports.createState = createState;
exports.debounce = debounce;
exports.deepClone = deepClone;
exports.deepCompare = deepCompare;
exports.defaultAreaPositionRestrictions = defaultAreaPositionRestrictions;
exports.defaultAreaSizeRestrictions = defaultAreaSizeRestrictions;
exports.defaultPosition = defaultPosition;
exports.defaultPositionRestrictions = defaultPositionRestrictions;
exports.defaultSize = defaultSize$1;
exports.defaultStencilConstraints = defaultStencilConstraints;
exports.defaultVisibleArea = defaultVisibleArea;
exports.diff = diff;
exports.distance = distance;
exports.drawCroppedArea = drawCroppedArea;
exports.emptyCoordinates = emptyCoordinates;
exports.fillBoundary = fillBoundary;
exports.fillMoveDirections = fillMoveDirections;
exports.fillResizeDirections = fillResizeDirections;
exports.fitBoundary = fitBoundary;
exports.fitCoordinates = fitCoordinates;
exports.fitDirections = fitDirections;
exports.fitToPositionRestrictions = fitToPositionRestrictions;
exports.fitToSizeRestrictions = fitToSizeRestrictions;
exports.fitVisibleArea = fitVisibleArea;
exports.flipImageAlgorithm = flipImageAlgorithm;
exports.getAreaPositionRestrictions = getAreaPositionRestrictions;
exports.getAreaSizeRestrictions = getAreaSizeRestrictions;
exports.getAspectRatio = getAspectRatio;
exports.getBackgroundStyle = getBackgroundStyle;
exports.getBrokenRatio = getBrokenRatio;
exports.getCenter = getCenter;
exports.getCloserAngle = getCloserAngle;
exports.getCloserSize = getCloserSize;
exports.getCoefficient = getCoefficient;
exports.getDefaultCoordinates = getDefaultCoordinates;
exports.getDefaultVisibleArea = getDefaultVisibleArea;
exports.getDirectionNames = getDirectionNames;
exports.getImageStyle = getImageStyle;
exports.getIntersections = getIntersections;
exports.getMinimumSize = getMinimumSize;
exports.getOptions = getOptions;
exports.getPositionRestrictions = getPositionRestrictions;
exports.getPreviewStyle = getPreviewStyle;
exports.getRoundedCoordinates = getRoundedCoordinates;
exports.getSizeRestrictions = getSizeRestrictions;
exports.getStencilCoordinates = getStencilCoordinates;
exports.getStyleTransforms = getStyleTransforms;
exports.getTransformedImageSize = getTransformedImageSize;
exports.getTransitionStyle = getTransitionStyle;
exports.inverseMove = inverseMove;
exports.isArray = isArray;
exports.isArrayBufferLike = isArrayBufferLike;
exports.isBlob = isBlob;
exports.isCardinalDirection = isCardinalDirection;
exports.isConsistentPosition = isConsistentPosition;
exports.isConsistentSize = isConsistentSize;
exports.isConsistentState = isConsistentState;
exports.isCrossOriginURL = isCrossOriginURL;
exports.isDataUrl = isDataUrl;
exports.isEqualState = isEqualState;
exports.isFunction = isFunction;
exports.isGreater = isGreater;
exports.isInitializedState = isInitializedState;
exports.isLocal = isLocal;
exports.isLower = isLower;
exports.isMouseEvent = isMouseEvent;
exports.isNaN = isNaN;
exports.isNumber = isNumber;
exports.isNumeric = isNumeric;
exports.isObject = isObject;
exports.isOrdinalDirection = isOrdinalDirection;
exports.isRoughlyEqual = isRoughlyEqual;
exports.isString = isString;
exports.isTouchEvent = isTouchEvent;
exports.isUndefined = isUndefined;
exports.isWheelEvent = isWheelEvent;
exports.loadImage = loadImage;
exports.maxScale = maxScale;
exports.mergePositionRestrictions = mergePositionRestrictions;
exports.mergeRefs = mergeRefs;
exports.mergeSizeRestrictions = mergeSizeRestrictions;
exports.minScale = minScale;
exports.moveCoordinates = moveCoordinates;
exports.moveCoordinatesAlgorithm = moveCoordinatesAlgorithm;
exports.moveToPositionRestrictions = moveToPositionRestrictions;
exports.normalizeCenter = normalizeCenter;
exports.normalizeFlip = normalizeFlip;
exports.normalizeImageTransform = normalizeImageTransform;
exports.normalizeMoveDirections = normalizeMoveDirections;
exports.normalizeResizeDirections = normalizeResizeDirections;
exports.parseNumber = parseNumber;
exports.pixelsRestrictions = pixelsRestrictions;
exports.positionToSizeRestrictions = positionToSizeRestrictions;
exports.prepareSource = prepareSource;
exports.promiseTimeout = promiseTimeout;
exports.ratio = ratio;
exports.reconcileSizeRestrictions = reconcileSizeRestrictions;
exports.reconcileState = reconcileState;
exports.resizeCoordinates = resizeCoordinates;
exports.resizeCoordinatesAlgorithm = resizeCoordinatesAlgorithm;
exports.resizeToSizeRestrictions = resizeToSizeRestrictions;
exports.retrieveSizeRestrictions = retrieveSizeRestrictions;
exports.rotateImageAlgorithm = rotateImageAlgorithm;
exports.rotatePoint = rotatePoint;
exports.rotateSize = rotateSize;
exports.setBoundary = setBoundary;
exports.setCoordinates = setCoordinates;
exports.setVisibleArea = setVisibleArea;
exports.sign = sign;
exports.sizeDistance = sizeDistance;
exports.stretchCropperBoundary = stretchCropperBoundary;
exports.stretchPreviewBoundary = stretchPreviewBoundary;
exports.touchesToImageTransform = touchesToImageTransform;
exports.transformImage = transformImage;
exports.transformImageAlgorithm = transformImageAlgorithm;
exports.updateCanvas = updateCanvas;
exports.useCropperImage = useCropperImage;
exports.useCropperState = useCropperState;
exports.useMoveImageOptions = useMoveImageOptions;
exports.useScaleImageOptions = useScaleImageOptions;
exports.useUpdateEffect = useUpdateEffect;
exports.useWindowResize = useWindowResize;
exports.wheelEventToImageTransform = wheelEventToImageTransform;
exports.withDefaultAreaPositionRestrictions = withDefaultAreaPositionRestrictions;
exports.withDefaultAreaSizeRestrictions = withDefaultAreaSizeRestrictions;
exports.withDefaultPositionRestrictions = withDefaultPositionRestrictions;
exports.withDefaultSizeRestrictions = withDefaultSizeRestrictions;
//# sourceMappingURL=index.cjs.js.map
