'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var index = require('../utils/index.js');
var utils = require('./utils.js');
var helpers = require('./helpers.js');

function reconcileSizeRestrictions(sizeRestrictions) {
    var restrictions = tslib.__assign({}, sizeRestrictions);
    // Process the border cases when minimum height / width larger than maximum height / width
    if (restrictions.minWidth > restrictions.maxWidth) {
        restrictions.minWidth = restrictions.maxWidth;
    }
    if (restrictions.minHeight > restrictions.maxHeight) {
        restrictions.minHeight = restrictions.maxHeight;
    }
    return restrictions;
}
function mergeSizeRestrictions(a, b) {
    var first = a;
    var second = tslib.__assign({ minWidth: 0, minHeight: 0, maxWidth: Infinity, maxHeight: Infinity }, b);
    return reconcileSizeRestrictions({
        maxHeight: Math.min(first.maxHeight, second.maxHeight),
        minHeight: Math.max(first.minHeight, second.minHeight),
        maxWidth: Math.min(first.maxWidth, second.maxWidth),
        minWidth: Math.max(first.minWidth, second.minWidth),
    });
}
function calculateSizeRestrictions(state, settings) {
    var sizeRestrictions = index.isFunction(settings.sizeRestrictions)
        ? settings.sizeRestrictions(state, settings)
        : settings.sizeRestrictions;
    var positionRestrictions = helpers.getPositionRestrictions(state, settings);
    // User can forget to set some of restrictions, so we should initialize them by default values
    var restrictions = {
        minWidth: index.isNumeric(sizeRestrictions.minWidth) ? index.parseNumber(sizeRestrictions.minWidth) : 0,
        minHeight: index.isNumeric(sizeRestrictions.minHeight) ? index.parseNumber(sizeRestrictions.minHeight) : 0,
        maxWidth: index.isNumeric(sizeRestrictions.maxWidth) ? index.parseNumber(sizeRestrictions.maxWidth) : Infinity,
        maxHeight: index.isNumeric(sizeRestrictions.maxHeight) ? index.parseNumber(sizeRestrictions.maxHeight) : Infinity,
    };
    // The situation, when stencil can't be positioned in cropper due to positionRestrictions should be avoided
    if (positionRestrictions.left !== undefined && positionRestrictions.right !== undefined) {
        restrictions.maxWidth = Math.min(restrictions.maxWidth, positionRestrictions.right - positionRestrictions.left);
    }
    if (positionRestrictions.bottom !== undefined && positionRestrictions.top !== undefined) {
        restrictions.maxHeight = Math.min(restrictions.maxHeight, positionRestrictions.bottom - positionRestrictions.top);
    }
    return reconcileSizeRestrictions(restrictions);
}
function calculateAreaSizeRestrictions(state, settings) {
    var sizeRestrictions = index.isFunction(settings.areaSizeRestrictions)
        ? settings.areaSizeRestrictions(state, settings)
        : settings.areaSizeRestrictions;
    if (sizeRestrictions.maxWidth < Infinity && sizeRestrictions.maxHeight < Infinity) {
        if (utils.ratio(state.boundary) > sizeRestrictions.maxWidth / sizeRestrictions.maxHeight) {
            sizeRestrictions.maxHeight = sizeRestrictions.maxWidth / utils.ratio(state.boundary);
        }
        else {
            sizeRestrictions.maxWidth = sizeRestrictions.maxHeight * utils.ratio(state.boundary);
        }
    }
    return reconcileSizeRestrictions(sizeRestrictions);
}

exports.calculateAreaSizeRestrictions = calculateAreaSizeRestrictions;
exports.calculateSizeRestrictions = calculateSizeRestrictions;
exports.mergeSizeRestrictions = mergeSizeRestrictions;
exports.reconcileSizeRestrictions = reconcileSizeRestrictions;
