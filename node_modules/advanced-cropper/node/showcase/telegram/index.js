'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var index = require('../../utils/index.js');
var utils = require('../../service/utils.js');
var helpers = require('../../service/helpers.js');
var copyState = require('../../state/copyState.js');
require('../../types/index.js');
require('../../state/setCoordinates.js');
var transformImage$1 = require('../../state/transformImage.js');
var resizeCoordinatesAlgorithm = require('../../algorithms/resizeCoordinatesAlgorithm.js');
var defaultStencilConstraints = require('../../defaults/defaultStencilConstraints.js');
var types = require('../../extensions/fit-to-image/types.js');
var size = require('../../extensions/fit-to-image/size.js');
var position = require('../../extensions/fit-to-image/position.js');
var utils$1 = require('../../extensions/fit-to-image/utils.js');

function stencilConstraints(rawSettings, stencilOptions) {
    var defaultConstraints = defaultStencilConstraints.defaultStencilConstraints({}, stencilOptions);
    return tslib.__assign({ stencilBoundingBox: stencilOptions.boundingBox }, defaultConstraints);
}
function transformImage(state, settings, transform) {
    var flip = transform.flip, rotate = transform.rotate, scale = transform.scale, move = transform.move;
    if (flip) {
        state = tslib.__assign(tslib.__assign({}, state), { transforms: tslib.__assign(tslib.__assign({}, state.transforms), { flip: {
                    horizontal: flip.horizontal ? !state.transforms.flip.horizontal : state.transforms.flip.horizontal,
                    vertical: flip.vertical ? !state.transforms.flip.vertical : state.transforms.flip.vertical,
                } }) });
    }
    if (state.coordinates) {
        if (!flip && !scale && !move) {
            state.basis = state.basis || tslib.__assign({}, state.coordinates);
        }
        else {
            state.basis = undefined;
        }
    }
    return transformImage$1.transformImage(state, settings, { rotate: rotate, move: move, scale: scale });
}
function resizeCoordinates(state, settings, directions, options) {
    if (helpers.isInitializedState(state)) {
        var result = copyState.copyState(state);
        var minimumSize = helpers.getMinimumSize(result);
        var imageSize = helpers.getTransformedImageSize(result);
        var sizeRestrictions = helpers.getSizeRestrictions(result, settings);
        result.coordinates = resizeCoordinatesAlgorithm.resizeCoordinatesAlgorithm(result.coordinates, directions, options, {
            positionRestrictions: utils.mergePositionRestrictions(helpers.getPositionRestrictions(result, settings), utils.coordinatesToPositionRestrictions(result.visibleArea)),
            sizeRestrictions: {
                maxWidth: Math.min(sizeRestrictions.maxWidth, imageSize.width, result.visibleArea.width),
                maxHeight: Math.min(sizeRestrictions.maxHeight, imageSize.height, result.visibleArea.height),
                minWidth: Math.max(Math.min(sizeRestrictions.minWidth, result.visibleArea.width), minimumSize),
                minHeight: Math.max(Math.min(sizeRestrictions.minHeight, result.visibleArea.height), minimumSize),
            },
            aspectRatio: helpers.getAspectRatio(result, settings),
        });
        var resizedCoordinates = tslib.__assign({}, result.coordinates);
        var approximatedSize = size.approximateSizeInsideImage({
            width: result.coordinates.width,
            height: result.coordinates.height,
            image: utils$1.getRotatedImage(result),
            boundingBox: settings.stencilBoundingBox,
            aspectRatio: helpers.getAspectRatio(result, settings),
            sizeRestrictions: helpers.getSizeRestrictions(result, settings),
        });
        result.coordinates = tslib.__assign({ left: utils.getCenter(resizedCoordinates).left - approximatedSize.width / 2, top: utils.getCenter(resizedCoordinates).top - approximatedSize.height / 2 }, approximatedSize);
        if (index.isGreater(Math.abs(resizedCoordinates.height - result.coordinates.height), 0)) {
            result.visibleArea = utils.applyScale(result.visibleArea, result.visibleArea.height /
                (result.visibleArea.height + resizedCoordinates.height - result.coordinates.height));
        }
        var fitDirections = position.fitToImage(result.coordinates, utils$1.getRotatedImage(result), settings.stencilBoundingBox);
        result.coordinates = utils.applyMove(result.coordinates, fitDirections);
        result.visibleArea = utils.applyMove(result.visibleArea, fitDirections);
        return result;
    }
    return state;
}
function defaultSize(state, settings) {
    var imageSize = helpers.getTransformedImageSize(state);
    return {
        width: state.visibleArea ? state.visibleArea.width : imageSize.width,
        height: state.visibleArea ? state.visibleArea.height : imageSize.height,
    };
}
function autoZoom(state, settings, action) {
    if (helpers.isInitializedState(state) && action.immediately) {
        var result = copyState.copyState(state);
        if (action.name !== 'transformImage' && action.name !== 'transformImageEnd') {
            if (!index.deepCompare(result.coordinates, result.basis)) {
                result.basis = undefined;
            }
        }
        var _a = settings.stencilBoundingBox, stencilBoundingBox = _a === void 0 ? types.BoundingBoxType.Rectangle : _a;
        var desiredSize = result.basis ? result.basis : result.coordinates;
        var size$1 = size.approximateSizeInsideImage({
            width: desiredSize.width,
            height: desiredSize.height,
            image: utils$1.getRotatedImage(state),
            aspectRatio: helpers.getAspectRatio(result, settings),
            sizeRestrictions: helpers.getSizeRestrictions(result, settings),
            boundingBox: stencilBoundingBox,
        });
        var previousCenter = utils.getCenter(result.coordinates);
        var currentCenter = utils.getCenter(tslib.__assign(tslib.__assign({}, result.coordinates), size$1));
        // Return to the original position adjusted for size's change
        result.coordinates = utils.applyMove(tslib.__assign(tslib.__assign({}, result.coordinates), size$1), utils.diff(previousCenter, currentCenter));
        // Move to fit image
        result.coordinates = position.moveToImage(result.coordinates, utils$1.getRotatedImage(result), stencilBoundingBox);
        result.visibleArea = utils.applyMove(result.visibleArea, utils.inverseMove(utils.fitToPositionRestrictions(result.coordinates, utils.coordinatesToPositionRestrictions(result.visibleArea))));
        // Auto size
        var stencil = {
            width: 0,
            height: 0,
        };
        if (utils.ratio(result.boundary) > utils.ratio(result.coordinates)) {
            stencil.height = result.boundary.height;
            stencil.width = stencil.height * utils.ratio(result.coordinates);
        }
        else {
            stencil.width = result.boundary.width;
            stencil.height = stencil.width * utils.ratio(result.coordinates);
        }
        // First of all try to resize visible area as much as possible:
        result.visibleArea = utils.applyScale(result.visibleArea, (result.coordinates.width * result.boundary.width) / (result.visibleArea.width * stencil.width));
        if (utils.ratio(result.boundary) > utils.ratio(result.coordinates)) {
            result.visibleArea.top = result.coordinates.top;
            result.visibleArea.left =
                result.coordinates.left - result.visibleArea.width / 2 + result.coordinates.width / 2;
        }
        else {
            result.visibleArea.left = result.coordinates.left;
            result.visibleArea.top =
                result.coordinates.top - result.visibleArea.height / 2 + result.coordinates.height / 2;
        }
        return result;
    }
    return state;
}

exports.autoZoom = autoZoom;
exports.defaultSize = defaultSize;
exports.resizeCoordinates = resizeCoordinates;
exports.stencilConstraints = stencilConstraints;
exports.transformImage = transformImage;
