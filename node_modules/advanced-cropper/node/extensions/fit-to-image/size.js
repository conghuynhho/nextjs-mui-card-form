'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('tslib');
var utils = require('../../service/utils.js');
var sizeRestrictions = require('../../service/sizeRestrictions.js');
require('../../types/index.js');
require('../../state/setCoordinates.js');
var types = require('./types.js');
var boundingBox = require('./boundingBox.js');

function imageToSizeRestrictions(image, aspectRatio, boundingBox$1) {
    var wrapper = boundingBox.getBoundingBox({
        width: aspectRatio,
        height: 1,
    }, image.angle, boundingBox$1);
    if (utils.ratio(image) >= utils.ratio(wrapper)) {
        return {
            minWidth: 0,
            minHeight: 0,
            maxHeight: image.height / wrapper.height,
            maxWidth: (image.height / wrapper.height) * aspectRatio,
        };
    }
    else {
        return {
            minWidth: 0,
            minHeight: 0,
            maxHeight: image.width / wrapper.width,
            maxWidth: (image.width / wrapper.width) * aspectRatio,
        };
    }
}
function approximateSizeInsideImage(params) {
    var width = params.width, height = params.height, image = params.image, sizeRestrictions$1 = params.sizeRestrictions, _a = params.boundingBox, boundingBox = _a === void 0 ? types.BoundingBoxType.Rectangle : _a;
    var aspectRatio = utils.createAspectRatio(params.aspectRatio);
    // Try to place the desired coordinates with respect to minimum size
    var coordinates = {
        width: Math.max(sizeRestrictions$1.minWidth, width),
        height: Math.max(sizeRestrictions$1.minHeight, height),
    };
    // Bounding box for the current coordinates
    var angleRestrictions = imageToSizeRestrictions(image, Math.min(aspectRatio.maximum, Math.max(aspectRatio.minimum, utils.ratio(coordinates))), boundingBox);
    // Consider the current size and the cropped by maximum bounding box size
    var candidates = [
        coordinates,
        {
            width: Math.min(sizeRestrictions$1.maxWidth, angleRestrictions.maxWidth),
            height: Math.min(sizeRestrictions$1.maxHeight, angleRestrictions.maxHeight),
        },
    ];
    // If we have some aspect ratio
    [aspectRatio.minimum, aspectRatio.maximum].forEach(function (ratio) {
        if (ratio && ratio !== Infinity) {
            var fittedSizeRestrictions = sizeRestrictions.mergeSizeRestrictions(sizeRestrictions$1, imageToSizeRestrictions(image, ratio, boundingBox));
            var width_1 = Math.min(coordinates.width, fittedSizeRestrictions.maxWidth);
            var height_1 = Math.min(coordinates.height, fittedSizeRestrictions.maxHeight);
            candidates.push({ width: width_1, height: width_1 / ratio }, { width: height_1 * ratio, height: height_1 });
        }
    });
    // Resize the candidates as much as possible to prevent breaking minimum size
    candidates = candidates.map(function (candidate) {
        return utils.resizeToSizeRestrictions(candidate, sizeRestrictions.mergeSizeRestrictions(imageToSizeRestrictions(image, utils.ratio(candidate), boundingBox), sizeRestrictions$1));
    });
    var candidate = utils.getCloserSize(candidates, { width: width, height: height }, function (size) { return sizeRestrictions.mergeSizeRestrictions(sizeRestrictions$1, imageToSizeRestrictions(image, utils.ratio(size), boundingBox)); }, aspectRatio);
    return candidate;
}

exports.approximateSizeInsideImage = approximateSizeInsideImage;
