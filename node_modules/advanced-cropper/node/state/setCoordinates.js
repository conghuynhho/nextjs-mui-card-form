'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var index = require('../utils/index.js');
var utils = require('../service/utils.js');
var helpers = require('../service/helpers.js');
var copyState = require('./copyState.js');
require('../types/index.js');
var approximateSize = require('../service/approximateSize.js');
var fitVisibleArea = require('../service/fitVisibleArea.js');
var moveCoordinatesAlgorithm = require('../algorithms/moveCoordinatesAlgorithm.js');

(function (SetCoordinatesMode) {
    SetCoordinatesMode["limit"] = "limit";
    SetCoordinatesMode["zoom"] = "zoom";
    SetCoordinatesMode["unsafe"] = "unsafe";
})(exports.SetCoordinatesMode || (exports.SetCoordinatesMode = {}));
function setCoordinates(state, settings, transform, 
// If you set mode to `false`, the coordinates can leave the visible area
mode) {
    if (mode === void 0) { mode = true; }
    var currentMode = mode === false ? exports.SetCoordinatesMode.unsafe : mode === true ? exports.SetCoordinatesMode.zoom : mode;
    var aspectRatio = helpers.getAspectRatio(state, settings);
    var sizeRestrictions = helpers.getSizeRestrictions(state, settings);
    if (state.visibleArea && currentMode === exports.SetCoordinatesMode.limit) {
        sizeRestrictions = tslib.__assign(tslib.__assign({}, sizeRestrictions), { minWidth: Math.min(state.visibleArea.width, sizeRestrictions.minWidth), minHeight: Math.min(state.visibleArea.height, sizeRestrictions.minHeight), maxWidth: Math.min(state.visibleArea.width, sizeRestrictions.maxWidth), maxHeight: Math.min(state.visibleArea.height, sizeRestrictions.maxHeight) });
    }
    var positionRestrictions = helpers.getPositionRestrictions(state, settings);
    if (state.visibleArea && currentMode === exports.SetCoordinatesMode.limit) {
        positionRestrictions = utils.mergePositionRestrictions(positionRestrictions, utils.coordinatesToPositionRestrictions(state.visibleArea));
    }
    var move = function (prevCoordinates, newCoordinates) {
        return moveCoordinatesAlgorithm.moveCoordinatesAlgorithm(prevCoordinates, {
            left: newCoordinates.left - (prevCoordinates.left || 0),
            top: newCoordinates.top - (prevCoordinates.top || 0),
        }, positionRestrictions);
    };
    var resize = function (prevCoordinates, newCoordinates) {
        var coordinates = tslib.__assign(tslib.__assign(tslib.__assign({}, prevCoordinates), approximateSize.approximateSize({
            width: newCoordinates.width,
            height: newCoordinates.height,
            sizeRestrictions: sizeRestrictions,
            aspectRatio: aspectRatio,
        })), { left: 0, top: 0 });
        return move(coordinates, {
            left: prevCoordinates.left || 0,
            top: prevCoordinates.top || 0,
        });
    };
    var coordinates = state.coordinates ? tslib.__assign({}, state.coordinates) : index.emptyCoordinates();
    var transforms = Array.isArray(transform) ? transform : [transform];
    transforms.forEach(function (transform) {
        var changes;
        if (typeof transform === 'function') {
            changes = transform(tslib.__assign(tslib.__assign({}, state), { coordinates: coordinates }), settings);
        }
        else {
            changes = transform;
        }
        if (changes) {
            if (!index.isUndefined(changes.width) || !index.isUndefined(changes.height)) {
                coordinates = resize(coordinates, tslib.__assign(tslib.__assign({}, coordinates), changes));
            }
            if (!index.isUndefined(changes.left) || !index.isUndefined(changes.top)) {
                coordinates = move(coordinates, tslib.__assign(tslib.__assign({}, coordinates), changes));
            }
        }
    });
    var result = tslib.__assign(tslib.__assign({}, copyState.copyState(state)), { coordinates: coordinates });
    if (result.visibleArea && currentMode === exports.SetCoordinatesMode.zoom) {
        var widthIntersections = Math.max(0, result.coordinates.width - result.visibleArea.width);
        var heightIntersections = Math.max(0, result.coordinates.height - result.visibleArea.height);
        var areaSizeRestrictions = helpers.getAreaSizeRestrictions(state, settings);
        var scale = widthIntersections > heightIntersections
            ? result.coordinates.width / result.visibleArea.width
            : result.coordinates.height / result.visibleArea.height;
        if (scale > 1) {
            result.visibleArea = utils.applyScale(result.visibleArea, Math.min(scale, utils.maxScale(result.visibleArea, areaSizeRestrictions)));
        }
        result.visibleArea = utils.applyMove(result.visibleArea, utils.inverseMove(utils.fitToPositionRestrictions(result.coordinates, utils.coordinatesToPositionRestrictions(result.visibleArea))));
        return fitVisibleArea.fitVisibleArea(result, settings);
    }
    else {
        return result;
    }
}

exports.setCoordinates = setCoordinates;
