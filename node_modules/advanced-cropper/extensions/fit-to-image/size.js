import 'tslib';
import { createAspectRatio, ratio, resizeToSizeRestrictions, getCloserSize } from '../../service/utils.js';
import { mergeSizeRestrictions } from '../../service/sizeRestrictions.js';
import '../../types/index.js';
import '../../state/setCoordinates.js';
import { BoundingBoxType } from './types.js';
import { getBoundingBox } from './boundingBox.js';

function imageToSizeRestrictions(image, aspectRatio, boundingBox) {
    var wrapper = getBoundingBox({
        width: aspectRatio,
        height: 1,
    }, image.angle, boundingBox);
    if (ratio(image) >= ratio(wrapper)) {
        return {
            minWidth: 0,
            minHeight: 0,
            maxHeight: image.height / wrapper.height,
            maxWidth: (image.height / wrapper.height) * aspectRatio,
        };
    }
    else {
        return {
            minWidth: 0,
            minHeight: 0,
            maxHeight: image.width / wrapper.width,
            maxWidth: (image.width / wrapper.width) * aspectRatio,
        };
    }
}
function approximateSizeInsideImage(params) {
    var width = params.width, height = params.height, image = params.image, sizeRestrictions = params.sizeRestrictions, _a = params.boundingBox, boundingBox = _a === void 0 ? BoundingBoxType.Rectangle : _a;
    var aspectRatio = createAspectRatio(params.aspectRatio);
    // Try to place the desired coordinates with respect to minimum size
    var coordinates = {
        width: Math.max(sizeRestrictions.minWidth, width),
        height: Math.max(sizeRestrictions.minHeight, height),
    };
    // Bounding box for the current coordinates
    var angleRestrictions = imageToSizeRestrictions(image, Math.min(aspectRatio.maximum, Math.max(aspectRatio.minimum, ratio(coordinates))), boundingBox);
    // Consider the current size and the cropped by maximum bounding box size
    var candidates = [
        coordinates,
        {
            width: Math.min(sizeRestrictions.maxWidth, angleRestrictions.maxWidth),
            height: Math.min(sizeRestrictions.maxHeight, angleRestrictions.maxHeight),
        },
    ];
    // If we have some aspect ratio
    [aspectRatio.minimum, aspectRatio.maximum].forEach(function (ratio) {
        if (ratio && ratio !== Infinity) {
            var fittedSizeRestrictions = mergeSizeRestrictions(sizeRestrictions, imageToSizeRestrictions(image, ratio, boundingBox));
            var width_1 = Math.min(coordinates.width, fittedSizeRestrictions.maxWidth);
            var height_1 = Math.min(coordinates.height, fittedSizeRestrictions.maxHeight);
            candidates.push({ width: width_1, height: width_1 / ratio }, { width: height_1 * ratio, height: height_1 });
        }
    });
    // Resize the candidates as much as possible to prevent breaking minimum size
    candidates = candidates.map(function (candidate) {
        return resizeToSizeRestrictions(candidate, mergeSizeRestrictions(imageToSizeRestrictions(image, ratio(candidate), boundingBox), sizeRestrictions));
    });
    var candidate = getCloserSize(candidates, { width: width, height: height }, function (size) { return mergeSizeRestrictions(sizeRestrictions, imageToSizeRestrictions(image, ratio(size), boundingBox)); }, aspectRatio);
    return candidate;
}

export { approximateSizeInsideImage };
